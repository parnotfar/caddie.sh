#!/usr/bin/env bash

source "$HOME/.caddie_modules/.caddie_core"

# Function to display caddie help
function caddie_help() {
    caddie cli:title "Caddie.sh - Development Environment Manager"
    caddie cli:blank
    
    caddie cli:usage "caddie <command>"
    caddie cli:blank
    
    caddie cli:title "Command Categories:"
    caddie cli:indent "home                     Home directory management"
    caddie cli:indent "aliases                  Alias search and management"
    
    caddie cli:title "Navigation:"
    caddie cli:indent "go:home                  Navigate to caddie home directory"
    
    caddie cli:title "Available modules:"

    local -a help_modules=()
    declare -A seen_help_modules=()

    if [ ${#CADDIE_MODULES[@]} -gt 0 ] 2>/dev/null; then
        for m in "${CADDIE_MODULES[@]}"; do
            if [ -n "$m" ] && [ -z "${seen_help_modules[$m]}" ]; then
                help_modules+=("$m")
                seen_help_modules[$m]=1
            fi
        done
    fi

    if [ ${#CADDIE_COMPLETION_ORDER[@]} -gt 0 ] 2>/dev/null; then
        for m in "${CADDIE_COMPLETION_ORDER[@]}"; do
            if [ -n "$m" ] && [ -z "${seen_help_modules[$m]}" ]; then
                help_modules+=("$m")
                seen_help_modules[$m]=1
            fi
        done
    fi

    if [ ${#help_modules[@]} -eq 0 ]; then
        caddie cli:indent "No modules registered"
    else
        local module=""
        local description_function=""
        local module_description=""
        for module in "${help_modules[@]}"; do
            description_function="caddie_${module}_description"
            module_description=""
            if declare -F "$description_function" >/dev/null 2>&1; then
                module_description="$($description_function)"
            fi
            if [ -z "$module_description" ]; then
                module_description="Registered module"
            fi
            printf "  %-10s %s\n" "$module" "$module_description"
        done
    fi
    
    caddie cli:blank
    caddie cli:title "General Commands:"
    caddie cli:indent "help                     Show this overview"
    caddie cli:indent "version                  Show caddie version"
    caddie cli:indent "reload                   Reload caddie"
    caddie cli:indent "(no args)                Launch interactive caddie prompt"
    caddie cli:blank
    caddie cli:title "Productivity:"
    caddie cli:indent "core:aliases             Show all available aliases"
    caddie cli:blank
    caddie cli:title "Detailed Help:"
    caddie cli:indent "Use 'caddie <module>:help' for detailed information on any module"
    caddie cli:blank
    return 0
}

# Function to show caddie version
function caddie_version() {
    if [ -f "$HOME/.caddie_version" ]; then
        source "$HOME/.caddie_version"
        caddie cli:package "Caddie.sh version: $CADDIE_SH_VERSION"
    else
        caddie cli:warning "Caddie.sh version: unknown"
    fi
    return 0
}

function _caddie_switch_list() {
    local active_module="${1:-}"

    caddie cli:title "Switch Targets"
    caddie cli:blank

    local -a help_modules=()
    declare -A seen_help_modules=()

    if [ ${#CADDIE_MODULES[@]} -gt 0 ] 2>/dev/null; then
        local m
        for m in "${CADDIE_MODULES[@]}"; do
            if [ -n "$m" ] && [ -z "${seen_help_modules[$m]}" ]; then
                help_modules+=("$m")
                seen_help_modules[$m]=1
            fi
        done
    fi

    if [ ${#CADDIE_COMPLETION_ORDER[@]} -gt 0 ] 2>/dev/null; then
        local m
        for m in "${CADDIE_COMPLETION_ORDER[@]}"; do
            if [ -n "$m" ] && [ -z "${seen_help_modules[$m]}" ]; then
                help_modules+=("$m")
                seen_help_modules[$m]=1
            fi
        done
    fi

    if [ ${#help_modules[@]} -eq 0 ]; then
        caddie cli:indent "No modules registered"
        return 0
    fi

    local -a display_modules=()
    local -a display_descriptions=()

    local shell_description="Shell command scope"
    if [ "$active_module" = "shell" ]; then
        shell_description="${shell_description} (current)"
    fi
    display_modules+=("shell")
    display_descriptions+=("$shell_description")

    local module=""
    local description_function=""
    local module_description=""
    for module in "${help_modules[@]}"; do
        description_function="caddie_${module}_description"
        module_description=""
        if declare -F "$description_function" >/dev/null 2>&1; then
            module_description="$($description_function)"
        fi
        if [ -z "$module_description" ]; then
            module_description="Registered module"
        fi
        if [ "$active_module" = "$module" ]; then
            module_description="${module_description} (current)"
        fi
        display_modules+=("$module")
        display_descriptions+=("$module_description")
    done

    local header_module="Module"
    local header_desc="Description"
    local module_width=${#header_module}
    local desc_width=${#header_desc}
    local i
    for ((i = 0; i < ${#display_modules[@]}; i++)); do
        if [ ${#display_modules[$i]} -gt "$module_width" ]; then
            module_width=${#display_modules[$i]}
        fi
        if [ ${#display_descriptions[$i]} -gt "$desc_width" ]; then
            desc_width=${#display_descriptions[$i]}
        fi
    done

    local module_col_width=$((module_width + 2))
    local desc_col_width=$((desc_width + 2))

    local box_tl box_tr box_bl box_br box_h box_v box_tm box_mm box_bm box_ml box_mr
    box_tl="$(printf '\xE2\x94\x8C')"
    box_tr="$(printf '\xE2\x94\x90')"
    box_bl="$(printf '\xE2\x94\x94')"
    box_br="$(printf '\xE2\x94\x98')"
    box_h="$(printf '\xE2\x94\x80')"
    box_v="$(printf '\xE2\x94\x82')"
    box_tm="$(printf '\xE2\x94\xAC')"
    box_mm="$(printf '\xE2\x94\xBC')"
    box_bm="$(printf '\xE2\x94\xB4')"
    box_ml="$(printf '\xE2\x94\x9C')"
    box_mr="$(printf '\xE2\x94\xA4')"

    local module_border
    local desc_border
    module_border="$(printf '%*s' "$module_col_width" '' | tr ' ' "$box_h")"
    desc_border="$(printf '%*s' "$desc_col_width" '' | tr ' ' "$box_h")"

    local line_top="${box_tl}${module_border}${box_tm}${desc_border}${box_tr}"
    local line_mid="${box_ml}${module_border}${box_mm}${desc_border}${box_mr}"
    local line_bottom="${box_bl}${module_border}${box_bm}${desc_border}${box_br}"

    local header_module_cell
    local header_desc_cell
    header_module_cell="$(printf "%-${module_width}s" "$header_module")"
    header_desc_cell="$(printf "%-${desc_width}s" "$header_desc")"

    caddie cli:indent "$line_top"
    caddie cli:indent "${box_v} ${BOLD}${WHITE}${header_module_cell}${RESET} ${box_v} ${BOLD}${WHITE}${header_desc_cell}${RESET} ${box_v}"
    caddie cli:indent "$line_mid"

    for ((i = 0; i < ${#display_modules[@]}; i++)); do
        local module_cell_plain
        local desc_cell_plain
        module_cell_plain="$(printf "%-${module_width}s" "${display_modules[$i]}")"
        desc_cell_plain="$(printf "%-${desc_width}s" "${display_descriptions[$i]}")"
        caddie cli:indent "${box_v} ${BOLD}${CYAN}${module_cell_plain}${RESET} ${box_v} ${GREY}${desc_cell_plain}${RESET} ${box_v}"
    done

    caddie cli:indent "$line_bottom"
    return 0
}

function _caddie_module_exists() {
    local needle="$1"
    local module

    if [ -z "$needle" ]; then
        return 1
    fi

    if [ "$needle" = "shell" ]; then
        return 0
    fi

    if [ ${#CADDIE_MODULES[@]} -gt 0 ] 2>/dev/null; then
        for module in "${CADDIE_MODULES[@]}"; do
            if [ "$module" = "$needle" ]; then
                return 0
            fi
        done
    fi

    if [ ${#CADDIE_COMPLETION_ORDER[@]} -gt 0 ] 2>/dev/null; then
        for module in "${CADDIE_COMPLETION_ORDER[@]}"; do
            if [ "$module" = "$needle" ]; then
                return 0
            fi
        done
    fi

    return 1
}

function _caddie_completion_commands_for_module() {
    local needle="$1"
    local i

    if [ -z "$needle" ]; then
        printf '%s' ""
        return 0
    fi

    if [ ${#CADDIE_COMPLETION_MODULES[@]} -gt 0 ] 2>/dev/null; then
        for ((i = 0; i < ${#CADDIE_COMPLETION_MODULES[@]}; i++)); do
            if [ "${CADDIE_COMPLETION_MODULES[$i]}" = "$needle" ]; then
                printf '%s' "${CADDIE_COMPLETION_COMMANDS[$i]}"
                return 0
            fi
        done
    fi

    printf '%s' ""
    return 0
}

function _caddie_command_prefix_exists() {
    local commands="$1"
    local candidate="$2"
    local cmd

    for cmd in $commands; do
        if [[ "$cmd" == "$candidate"* ]]; then
            return 0
        fi
    done
    return 1
}

function _caddie_command_exact_exists() {
    local commands="$1"
    local candidate="$2"
    local cmd

    for cmd in $commands; do
        if [ "$cmd" = "$candidate" ]; then
            return 0
        fi
    done
    return 1
}

function _caddie_join_args() {
    local out=""
    local arg
    local escaped=""

    for arg in "$@"; do
        printf -v escaped '%q' "$arg"
        if [ -n "$out" ]; then
            out+=" "
        fi
        out+="$escaped"
    done

    printf '%s' "$out"
    return 0
}

function _caddie_resolve_command_from_tokens() {
    local module="$1"
    local rest="$2"
    local commands=""
    local candidate=""
    local best=""
    local best_index=0
    local i
    local token
    local args_str=""
    local -a tokens=()
    local -a args=()

    if [ -z "$module" ]; then
        printf '%s\n' ""
        return 0
    fi

    if [ -n "$rest" ]; then
        if eval "set -- $rest" 2>/dev/null; then
            tokens=("$@")
        else
            IFS=' ' read -r -a tokens <<< "$rest"
        fi
    fi

    if [ "${#tokens[@]}" -eq 0 ]; then
        printf '%s\n' "${module}:help"
        return 0
    fi

    commands="$(_caddie_completion_commands_for_module "$module")"
    candidate="$module"

    for ((i = 0; i < ${#tokens[@]}; i++)); do
        token="${tokens[$i]}"
        if [[ "$token" == -* ]]; then
            break
        fi
        if ! [[ "$token" =~ ^[[:alnum:]_-]+$ ]]; then
            break
        fi

        candidate="${candidate}:${token}"

        if [ -n "$commands" ]; then
            if _caddie_command_prefix_exists "$commands" "$candidate"; then
                if _caddie_command_exact_exists "$commands" "$candidate"; then
                    best="$candidate"
                    best_index=$((i + 1))
                fi
                continue
            fi
            break
        fi

        if command -v "caddie_${candidate//:/_}" >/dev/null 2>&1; then
            best="$candidate"
            best_index=$((i + 1))
        else
            if [ -z "$best" ]; then
                best="${module}:${tokens[0]}"
                best_index=1
            fi
            break
        fi
    done

    if [ -z "$best" ]; then
        best="${module}:${tokens[0]}"
        best_index=1
    fi

    args=("${tokens[@]:$best_index}")
    if [ "${#args[@]}" -gt 0 ]; then
        args_str="$(_caddie_join_args "${args[@]}")"
        printf '%s\n' "${best} ${args_str}"
    else
        printf '%s\n' "${best}"
    fi
    return 0
}

function _caddie_repl_normalize() {
    local line="$1"
    local active_module="${2:-}"
    local allow_scopes="${3:-1}"

    line="${line#${line%%[![:space:]]*}}"
    line="${line%${line##*[![:space:]]}}"

    if [ -z "$line" ]; then
        printf '%s\n' ""
        return 0
    fi

    if [[ "$line" == \`* ]] && [[ "$line" == *\` ]] && [ "${#line}" -ge 2 ]; then
        local shell_inline
        shell_inline="${line#\`}"  # trim leading backtick
        shell_inline="${shell_inline%\`}"  # trim trailing backtick
        printf '__SHELL_EVAL__%s\n' "$shell_inline"
        return 0
    fi

    if [ "$allow_scopes" = "1" ]; then
        case "$line" in
            switch|switch[[:space:]]*)
                local switch_target
                switch_target="${line#switch}"
                switch_target="${switch_target#${switch_target%%[![:space:]]*}}"
                if [ -n "$switch_target" ]; then
                    printf '%s\n' "__SWITCH_MODULE__:${switch_target}"
                else
                    printf '%s\n' "__SWITCH_MODULE__"
                fi
                return 0
                ;;
        esac
    fi

    case "$line" in
        exit|quit|q)
            printf '%s\n' "__EXIT__"
            return 0
            ;;
        back|up|..)
            if [ -n "$active_module" ] && [ "$allow_scopes" = "1" ]; then
                printf '%s\n' "__MODULE_EXIT__"
                return 0
            fi
            ;;
        i|info)
            if [ -n "$active_module" ] && [ "$active_module" != "shell" ]; then
                printf '%s\n' "${active_module}:info"
            else
                printf '%s\n' "core:info"
            fi
            return 0
            ;;
        help|--help|-h)
            if [ -n "$active_module" ]; then
                if [ "$active_module" = "shell" ]; then
                    printf '%s\n' "__SHELL_HELP__"
                else
                    printf '%s\n' "${active_module}:help"
                fi
            else
                printf '%s\n' "$line"
            fi
            return 0
            ;;
        version|--version|-v|reload|--reload|-r|go:home)
            printf '%s\n' "$line"
            return 0
            ;;
    esac

    if [[ "$line" == :* ]]; then
        printf '%s\n' "${line#:}"
        return 0
    fi

    local first_token
    first_token="${line%%[[:space:]]*}"

    if [ "$active_module" = "shell" ]; then
        printf '__SHELL_EVAL__%s\n' "$line"
        return 0
    fi

    if [ -n "$active_module" ]; then
        if [[ "$first_token" == *:* ]]; then
            printf '%s\n' "$line"
            return 0
        fi

        if [ "$line" = "$first_token" ] && _caddie_module_exists "$first_token" && [ "$allow_scopes" = "1" ]; then
            printf '%s\n' "__SET_MODULE__:${first_token}"
            return 0
        fi

        line="${active_module} ${line}"
        line="${line#${line%%[![:space:]]*}}"
        line="${line%${line##*[![:space:]]}}"
        first_token="${line%%[[:space:]]*}"
    fi

    if [[ "$first_token" == *:* ]]; then
        printf '%s\n' "$line"
        return 0
    fi

    local module rest
    module="${line%%[[:space:]]*}"
    rest="${line#${module}}"
    rest="${rest#${rest%%[![:space:]]*}}"

    if [ "$module" = "shell" ]; then
        if [ -z "$rest" ]; then
            if [ "$allow_scopes" = "1" ]; then
                printf '%s\n' "__SET_MODULE__:shell"
                return 0
            fi
            printf '%s\n' "shell:help"
            return 0
        fi
        case "$rest" in
            help|--help|-h)
                printf '%s\n' "__SHELL_HELP__"
                return 0
                ;;
        esac
        printf '__SHELL_EVAL__%s\n' "$rest"
        return 0
    fi

    if [ "$module" = "$line" ]; then
        if _caddie_module_exists "$module"; then
            if [ "$allow_scopes" = "1" ]; then
                printf '%s\n' "__SET_MODULE__:${module}"
                return 0
            fi
        fi
        printf '%s\n' "${module}:help"
        return 0
    fi

    _caddie_resolve_command_from_tokens "$module" "$rest"
    return $?
}

function _caddie_repl() {
    local line normalized status=0
    local prompt_name="caddie"
    local prompt_version=""
    local prompt_version_value=""
    local prompt_label="caddie"
    local active_module=""
    local history_file="${CADDIE_HISTORY_FILE:-$HOME/.caddie_history}"
    local history_initial_size
    local history_entries_added=0
    local -a repl_new_entries=()

    local previous_int_trap
    previous_int_trap="$(trap -p INT)"
    local interrupted=0
    trap 'interrupted=1' INT

    if [ -f "$HOME/.caddie_version" ]; then
        # shellcheck disable=SC1090
        source "$HOME/.caddie_version"
        if [ -n "${CADDIE_SH_VERSION:-}" ]; then
            prompt_version="-${CADDIE_SH_VERSION}"
            prompt_version_value="$CADDIE_SH_VERSION"
            prompt_label="${prompt_name}${prompt_version}"
        fi
    fi

    local prompt_color_enabled=0
    local prompt_color_reset=""
    local prompt_color_name=""
    local prompt_color_module=""
    local prompt_color_version=""
    local prompt_color_bracket=""
    local prompt_color_dash=""
    local prompt_color_prompt=""

    if [ -t 1 ] && command -v tput >/dev/null 2>&1; then
        local np_start=$'\001'
        local np_end=$'\002'
        local tput_reset
        tput_reset="$(tput sgr0 2>/dev/null || printf '')"
        if [ -n "$tput_reset" ]; then
            prompt_color_enabled=1
            prompt_color_reset="${np_start}${tput_reset}${np_end}"
            prompt_color_name="${np_start}$(tput setaf 6 2>/dev/null || printf '')${np_end}"
            prompt_color_module="${np_start}$(tput setaf 5 2>/dev/null || printf '')${np_end}"
            prompt_color_version="${np_start}$(tput setaf 3 2>/dev/null || printf '')${np_end}"
            prompt_color_bracket="${np_start}$(tput setaf 8 2>/dev/null || printf '')${np_end}"
            prompt_color_dash="${np_start}$(tput setaf 7 2>/dev/null || printf '')${np_end}"
            prompt_color_prompt="${np_start}$(tput setaf 4 2>/dev/null || printf '')${np_end}"
        fi
    fi

    # Only load history when REPL is actually invoked, not during sourcing
    history_initial_size=$(builtin history 2>/dev/null | wc -l | tr -d '[:space:]')
    if ! [[ "$history_initial_size" =~ ^[0-9]+$ ]]; then
        history_initial_size=0
    fi

    if [ -f "$history_file" ]; then
        while IFS= read -r history_line; do
            if [ -n "$history_line" ]; then
                builtin history -s "$history_line" 2>/dev/null || true
                history_entries_added=$((history_entries_added + 1))
            fi
        done < "$history_file"
    fi

    while true; do
        if [ -n "$active_module" ]; then
            prompt_label="${prompt_name}[${active_module}]${prompt_version}"
        else
            prompt_label="${prompt_name}${prompt_version}"
        fi

        local prompt_display
        if [ "$prompt_color_enabled" -eq 1 ]; then
            local colored_label
            colored_label="${prompt_color_name}${prompt_name}${prompt_color_reset}"
            if [ -n "$active_module" ]; then
                colored_label+="${prompt_color_bracket}[${prompt_color_module}${active_module}${prompt_color_bracket}]${prompt_color_reset}"
            fi
            if [ -n "$prompt_version_value" ]; then
                colored_label+="${prompt_color_dash}-${prompt_color_version}${prompt_version_value}${prompt_color_reset}"
            fi
            prompt_display="${colored_label}${prompt_color_prompt}> ${prompt_color_reset}"
        else
            prompt_display="${prompt_label}> "
        fi

        interrupted=0
        if ! builtin read -e -r -p "$prompt_display" line; then
            if [ "$interrupted" = "1" ]; then
                printf '\n'
                interrupted=0
                continue
            fi
            printf '\n'
            break
        fi

        local trimmed_line="$line"
        trimmed_line="${trimmed_line#${trimmed_line%%[![:space:]]*}}"
        trimmed_line="${trimmed_line%${trimmed_line##*[![:space:]]}}"

        if [ -n "$trimmed_line" ]; then
            builtin history -s "$trimmed_line" 2>/dev/null || true
            history_entries_added=$((history_entries_added + 1))
            repl_new_entries+=("$trimmed_line")
        fi

        line="$trimmed_line"

        local normalized
        local normalized_set=0

        if [[ "$line" == \`* ]] && [[ "$line" == *\` ]] && [ "${#line}" -ge 2 ]; then
            local shell_inline
            shell_inline="${line#\`}"
            shell_inline="${shell_inline%\`}"
            normalized="__SHELL_EVAL__${shell_inline}"
            normalized_set=1
        elif [ "$active_module" = "shell" ]; then
            case "$line" in
                back|up|..)
                    normalized="__MODULE_EXIT__"
                    normalized_set=1
                    ;;
                switch|switch[[:space:]]*)
                    local switch_target
                    switch_target="${line#switch}"
                    switch_target="${switch_target#${switch_target%%[![:space:]]*}}"
                    if [ -n "$switch_target" ]; then
                        normalized="__SWITCH_MODULE__:${switch_target}"
                    else
                        normalized="__SWITCH_MODULE__"
                    fi
                    normalized_set=1
                    ;;
                help|--help|-h)
                    normalized="__SHELL_HELP__"
                    normalized_set=1
                    ;;
                "")
                    normalized=""
                    normalized_set=1
                    ;;
                *)
                    normalized="__SHELL_EVAL__${line}"
                    normalized_set=1
                    ;;
            esac
        fi

        if [ "$normalized_set" -eq 0 ]; then
            normalized="$(_caddie_repl_normalize "$line" "$active_module")"
        fi

        case "$normalized" in
            "")
                continue
                ;;
            "__EXIT__")
                break
                ;;
            "__MODULE_EXIT__")
                if [ -n "$active_module" ]; then
                    caddie cli:indent "Leaving module '${active_module}'"
                    active_module=""
                fi
                continue
                ;;
            "__SHELL_HELP__")
                caddie cli:title "Shell Scope"
                caddie cli:indent "Run shell commands directly from the REPL without leaving context."
                caddie cli:indent "Use backticks or 'shell <cmd>' for one-offs, or enter the scope with 'shell'."
                caddie cli:indent "Leave the shell scope with 'back', 'up', or '..'."
                caddie cli:indent "Jump to another module with 'switch <module>'."
                continue
                ;;
            "__SWITCH_MODULE__")
                _caddie_switch_list "$active_module"
                continue
                ;;
            __SWITCH_MODULE__*)
                local switch_target
                local switch_module
                local switch_remainder
                switch_target="${normalized#__SWITCH_MODULE__:}"
                switch_target="${switch_target#${switch_target%%[![:space:]]*}}"
                switch_module="${switch_target%%[[:space:]]*}"
                switch_remainder="${switch_target#${switch_module}}"
                switch_remainder="${switch_remainder#${switch_remainder%%[![:space:]]*}}"

                if [ -z "$switch_module" ]; then
                    caddie cli:usage "switch <module>"
                    caddie cli:indent "Use 'help' to list available modules."
                    continue
                fi

                if [ -n "$switch_remainder" ]; then
                    caddie cli:red "Error: switch expects a single module name"
                    caddie cli:usage "switch <module>"
                    continue
                fi

                if ! _caddie_module_exists "$switch_module"; then
                    caddie cli:red "Error: Unknown module '${switch_module}'"
                    caddie cli:indent "Use 'help' to list available modules."
                    continue
                fi

                if [ -n "$active_module" ] && [ "$active_module" != "$switch_module" ]; then
                    caddie cli:indent "Leaving module '${active_module}'"
                fi
                active_module="$switch_module"
                caddie cli:title "Module scope: ${active_module}"
                continue
                ;;
            __SET_MODULE__*)
                active_module="${normalized#__SET_MODULE__:}"
                caddie cli:title "Module scope: ${active_module}"
                continue
                ;;
            __SHELL_EVAL__*)
                local shell_command
                shell_command="${normalized#__SHELL_EVAL__}"
                if [ -n "$shell_command" ]; then
                    interrupted=0
                    builtin eval "$shell_command"
                    status=$?
                else
                    status=0
                fi
                continue
                ;;
        esac

        if ! eval "set -- $normalized" 2>/dev/null; then
            caddie cli:red "Error: Unable to parse input"
            continue
        fi

        if [ $# -eq 0 ]; then
            continue
        fi

        interrupted=0
        caddie "$@"
        status=$?
    done

    if [ -n "$previous_int_trap" ]; then
        eval "$previous_int_trap"
    else
        trap - INT
    fi

    if [ ${#repl_new_entries[@]} -gt 0 ]; then
        if [ -z "$history_file" ]; then
            history_file="$HOME/.caddie_history"
        fi
        # Ensure directory exists when using nested path
        local history_dir
        history_dir="${history_file%/*}"
        if [ -n "$history_dir" ] && [ "$history_dir" != "$history_file" ]; then
            mkdir -p "$history_dir" 2>/dev/null || true
        fi
        printf '%s\n' "${repl_new_entries[@]}" >> "$history_file"
    fi

    if [ "$history_entries_added" -gt 0 ]; then
        local delete_index=$((history_initial_size + 1))
        local i
        for ((i = 0; i < history_entries_added; i++)); do
            builtin history -d "$delete_index" 2>/dev/null || true
        done
    fi

    return $status
}

# Main caddie function - directly executes commands and exposes REPL when no args
function caddie() {
    if [ $# -eq 0 ]; then
        _caddie_repl
        return $?
    fi

    if [[ "$1" != *:* ]]; then
        local normalized
        normalized="$(_caddie_repl_normalize "$*" "" "0")"

        if [ "$normalized" = "__EXIT__" ]; then
            return 0
        fi

        if [ "$normalized" = "__SHELL_HELP__" ]; then
            caddie cli:title "Shell Integration"
            caddie cli:indent "Use backticks (\`command\`) to run ad-hoc shell commands inside the REPL."
            caddie cli:indent "Type 'shell <command>' for one-off commands or 'shell' to enter shell scope."
            caddie cli:indent "Exit shell scope with 'back', 'up', or '..'."
            caddie cli:indent "Jump to another module with 'switch <module>'."
            return 0
        fi

        if [[ "$normalized" == __SHELL_EVAL__* ]]; then
            local shell_cmd
            shell_cmd="${normalized#__SHELL_EVAL__}"
            if [ -n "$shell_cmd" ]; then
                builtin eval "$shell_cmd"
                return $?
            fi
            return 0
        fi

        if [ -n "$normalized" ]; then
            if ! eval "set -- $normalized" 2>/dev/null; then
                caddie cli:red "Unable to parse command"
                return 1
            fi
        else
            return 0
        fi
    fi

    local command="$1"
    shift || true

    case "$command" in
        help|--help|-h)
            caddie_help
            return 0
            ;;
        version|--version|-v)
            caddie_version
            return 0
            ;;
        reload|--reload|-r)
            source "$HOME/.bash_profile"
            return 0
            ;;
        go:home)
            caddie_core_go_home "$@"
            return 0
            ;;
        shell:help)
            caddie cli:title "Shell Integration"
            caddie cli:indent "Use backticks (\`command\`) to run ad-hoc shell commands inside the REPL."
            caddie cli:indent "Type 'shell <command>' for one-off commands or 'shell' to enter shell scope."
            caddie cli:indent "Exit shell scope with 'back', 'up', or '..'."
            return 0
            ;;
    esac

    local function_name="caddie_${command//:/_}"

    if command -v "$function_name" >/dev/null 2>&1; then
        eval "$function_name \"\$@\""
    else
        caddie cli:red "Error: Unknown command '$command'"
        caddie_help
        return 1
    fi
}

# --- completion setup ---
# 1) make ':' not break words (so ruby:add stays one token)
COMP_WORDBREAKS=${COMP_WORDBREAKS//:/}

# Use regular arrays instead of associative arrays for compatibility
CADDIE_COMPLETION_MODULES=()
CADDIE_COMPLETION_COMMANDS=()
CADDIE_COMPLETION_ORDER=()

function caddie_completion_clear() {
  CADDIE_COMPLETION_MODULES=()
  CADDIE_COMPLETION_COMMANDS=()
  CADDIE_COMPLETION_ORDER=()
  return 0
}

function caddie_completion_register() {
  local module="$1"
  local commands="$2"

  if [ -z "$module" ] || [ -z "$commands" ]; then
    return 1
  fi

  # Check if module already exists in indexed arrays
  local i
  for ((i = 0; i < ${#CADDIE_COMPLETION_MODULES[@]}; i++)); do
    if [ "${CADDIE_COMPLETION_MODULES[$i]}" = "$module" ]; then
      # Update existing entry
      CADDIE_COMPLETION_COMMANDS[$i]="$commands"
      return 0
    fi
  done

  # Add new module
  CADDIE_COMPLETION_MODULES+=("$module")
  CADDIE_COMPLETION_COMMANDS+=("$commands")

  local existing_module
  for existing_module in "${CADDIE_COMPLETION_ORDER[@]}"; do
    if [ "$existing_module" = "$module" ]; then
      return 0
    fi
  done

  CADDIE_COMPLETION_ORDER+=("$module")
  return 0
}

export -f caddie_completion_clear
export -f caddie_completion_register

function _caddie_completion() {
  local cur prev words cword
  COMPREPLY=()

  # Prefer bash-completion helper if present; otherwise manual
  if declare -F _get_comp_words_by_ref >/dev/null 2>&1; then
    _get_comp_words_by_ref -n : cur prev words cword
  else
    words=("${COMP_WORDS[@]}")
    cword=${COMP_CWORD:-0}
    cur=${words[$cword]}
    prev=${words[$((cword-1))]}
  fi

  if [[ "$prev" == git:pr:approve ]]; then
    local pr_candidates=""

    if declare -F caddie_git_pr_completion_candidates >/dev/null 2>&1; then
      pr_candidates=$(caddie_git_pr_completion_candidates 2>/dev/null || true)
    fi

    if [ -n "$pr_candidates" ]; then
      COMPREPLY=()
      while IFS= read -r line; do
        COMPREPLY+=("$line")
      done < <(compgen -W "$pr_candidates" -- "$cur")
    else
      COMPREPLY=()
    fi

    return 0
  fi

  if [[ "$prev" == git:worktree:remove ]]; then
    local wt_candidates=""
    if declare -F caddie_git_worktree_completion_candidates >/dev/null 2>&1; then
      wt_candidates=$(caddie_git_worktree_completion_candidates "removable" 2>/dev/null || true)
    fi
    COMPREPLY=()
    if [ -n "$wt_candidates" ]; then
      while IFS= read -r line; do
        COMPREPLY+=("$line")
      done < <(compgen -W "$wt_candidates" -- "$cur")
    fi
    return 0
  fi

  if [[ "$prev" == git:worktree:lock ]]; then
    local wt_candidates=""
    if declare -F caddie_git_worktree_completion_candidates >/dev/null 2>&1; then
      wt_candidates=$(caddie_git_worktree_completion_candidates "lock" 2>/dev/null || true)
    fi
    COMPREPLY=()
    if [ -n "$wt_candidates" ]; then
      while IFS= read -r line; do
        COMPREPLY+=("$line")
      done < <(compgen -W "$wt_candidates" -- "$cur")
    fi
    return 0
  fi

  if [[ "$prev" == git:worktree:unlock ]]; then
    local wt_candidates=""
    if declare -F caddie_git_worktree_completion_candidates >/dev/null 2>&1; then
      wt_candidates=$(caddie_git_worktree_completion_candidates "unlock" 2>/dev/null || true)
    fi
    COMPREPLY=()
    if [ -n "$wt_candidates" ]; then
      while IFS= read -r line; do
        COMPREPLY+=("$line")
      done < <(compgen -W "$wt_candidates" -- "$cur")
    fi
    return 0
  fi

  if [[ "$prev" == git:worktree:cd ]]; then
    local wt_candidates=""
    if declare -F caddie_git_worktree_completion_candidates >/dev/null 2>&1; then
      wt_candidates=$(caddie_git_worktree_completion_candidates "all" 2>/dev/null || true)
    fi
    COMPREPLY=()
    if [ -n "$wt_candidates" ]; then
      while IFS= read -r line; do
        COMPREPLY+=("$line")
      done < <(compgen -W "$wt_candidates" -- "$cur")
    fi
    return 0
  fi

  if [[ "$prev" == swift:xcode:play:trace || "$prev" == swift:xcode:play:full ]]; then
    local template_candidates=""
    if declare -F caddie_swift_xcode_trace_template_candidates >/dev/null 2>&1; then
      template_candidates=$(caddie_swift_xcode_trace_template_candidates 2>/dev/null || true)
    fi
    COMPREPLY=()
    if [ -n "$template_candidates" ]; then
      while IFS= read -r line; do
        COMPREPLY+=("$line")
      done < <(compgen -W "$template_candidates" -- "$cur")
    fi
    return 0
  fi

  # Build a flat list of all accepted commands
  local base_opts="help version go:home shell --help -h --version -v reload --reload -r"
  local all_opts="$base_opts"

  if [ ${#CADDIE_COMPLETION_MODULES[@]} -gt 0 ] 2>/dev/null; then
    local i
    for ((i = 0; i < ${#CADDIE_COMPLETION_MODULES[@]}; i++)); do
      local completion_module="${CADDIE_COMPLETION_MODULES[$i]}"
      local completion_cmds="${CADDIE_COMPLETION_COMMANDS[$i]}"
      if [ -n "$completion_cmds" ]; then
        all_opts+=" $completion_cmds"
      fi
    done
  fi
  
  # Complete with all available commands
  COMPREPLY=()
  while IFS= read -r line; do
    COMPREPLY+=("$line")
  done < <(compgen -W "$all_opts" -- "$cur")
  
  # If we have multiple completions and the current word contains a colon,
  # try to provide more specific completions for subcommands
  if [[ ${#COMPREPLY[@]} -gt 1 && "$cur" == *:* ]]; then
    # Extract the prefix (everything before the last colon)
    local prefix="${cur%:*}"
    local subcommand_prefix="$prefix:"
    
    # Filter completions to only show those that start with the subcommand prefix
    local filtered_completions=()
    for completion in "${COMPREPLY[@]}"; do
      if [[ "$completion" == "$subcommand_prefix"* ]]; then
        filtered_completions+=("$completion")
      fi
    done
    
    # If we found filtered completions, use them
    if [[ ${#filtered_completions[@]} -gt 0 ]]; then
      COMPREPLY=("${filtered_completions[@]}")
    fi
  fi
  
  return 0
}

# Helper function to extract module name from filename
function caddie_extract_module_name() {
    local filename="$1"
    basename "$filename" | sed 's/^\.caddie_//'
}

# Export the caddie function and helper functions so they're available in subshells
export -f caddie
export -f caddie_help
export -f caddie_version

# Source the dependent files
source "$HOME/.caddie_version"
source "$HOME/.caddie_prompt.sh"

# Source data structure files
source "$HOME/.caddie_data/.caddie_modules"

# Auto-discover caddie modules from ~/.caddie_modules/ directory
# Each module file should have functions named <module>_caddie_description and <module>_caddie_help
CADDIE_MODULES_DIR="$HOME/.caddie_modules"

# Function to load caddie modules
function _caddie_load_modules() {
    if [ -d "$CADDIE_MODULES_DIR" ]; then
        # Reset modules array before loading
        caddie_modules_reset
        caddie_prompt_clear_segments
        caddie_completion_clear

        # Load all modules and populate modules array
        for file in "$CADDIE_MODULES_DIR"/.caddie_*; do
            if [ -f "$file" ]; then
                module_name=""
                prompt_fn=""
                completion_registered=0
                completion_fn=""
                completion_output=""
                source "$file"
                module_name="$(caddie_extract_module_name "$file")"
                caddie_modules_append "$module_name"
                prompt_fn="caddie_${module_name}_prompt_segment"
                if declare -F "$prompt_fn" >/dev/null 2>&1; then
                    caddie_prompt_register_segment "$prompt_fn"
                fi

                completion_registered=0
                completion_fn="caddie_${module_name}_commands"
                if declare -F "$completion_fn" >/dev/null 2>&1; then
                    completion_output="$($completion_fn)"
                    if [ -n "$completion_output" ]; then
                        caddie_completion_register "$module_name" "$completion_output"
                        completion_registered=1
                    fi
                fi

                if [ "$completion_registered" != "1" ]; then
                    case "$module_name" in
                      python)
                        caddie_completion_register "$module_name" "python:info python:init python:install python:update python:venv:activate python:venv:deactivate python:build python:test python:run python:lint python:format python:pip:freeze python:pip:audit"
                        ;;
                      ruby)
                        caddie_completion_register "$module_name" "ruby:info ruby:setup ruby:install ruby:use ruby:list ruby:current ruby:version ruby:pin:set ruby:pin:get ruby:pin:unset ruby:gemset:create ruby:gemset:use ruby:gemset:list ruby:gemset:delete ruby:gem:install ruby:gem:uninstall ruby:gem:list ruby:gem:update ruby:gem:outdated ruby:project:init ruby:project:test ruby:project:build ruby:project:serve ruby:bundler:install ruby:bundler:update ruby:bundler:exec ruby:rails:new ruby:rails:server ruby:rails:console ruby:rails:generate ruby:rails:migrate ruby:rails:routes"
                        ;;
                      js)
                        caddie_completion_register "$module_name" "js:info js:init js:install js:add js:update js:build js:dev js:start js:test js:lint js:format js:audit"
                        ;;
                      rust)
                        caddie_completion_register "$module_name" "rust:info rust:init rust:new rust:build rust:run rust:run:example rust:example:run rust:test rust:test:unit rust:test:integration rust:test:all rust:test:property rust:test:bench rust:test:watch rust:test:coverage rust:add rust:remove rust:fmt rust:format rust:clippy rust:check rust:fix rust:fix:all rust:clean rust:update rust:search rust:outdated rust:audit rust:toolchain rust:target rust:component rust:git:status rust:gitignore rust:git:clean"
                        ;;
                      ios)
                        caddie_completion_register "$module_name" "ios:info ios:archive ios:archive:testflight ios:export:ipa ios:upload:testflight ios:testflight ios:testflight:publish ios:testflight:publish:increment:false ios:project:info ios:version:get ios:version:set ios:increment:build ios:config:get ios:config:set ios:config:unset ios:config:list ios:config:load:project ios:keychain:password:set ios:keychain:password:get ios:keychain:password:unset"
                        ;;
                      swift)
                        caddie_completion_register "$module_name" "swift:info swift:init swift:build swift:run swift:run:tool swift:test swift:test:filter swift:package:resolve swift:package:update swift:package:clean swift:package:describe swift:xcode:packages:check swift:xcode:packages:add swift:xcode:resolve swift:xcode:build swift:xcode:build:log swift:xcode:play swift:xcode:play:logs swift:xcode:play:trace swift:xcode:play:full swift:xcode:trace:templates swift:xcode:scene:get swift:xcode:scene:set swift:xcode:scene:unset swift:xcode:target:get swift:xcode:target:set swift:xcode:target:unset swift:xcode:test swift:xcode:test:unit swift:xcode:test:unit:failed swift:xcode:test:unit:log:get swift:xcode:test:unit:log:set swift:xcode:test:unit:log:unset swift:xcode:crash:stream swift:xcode:crash:stream:all swift:xcode:crash:latest swift:xcode:crash:symbolicate swift:xcode:clean swift:format swift:lint swift:gitignore"
                        ;;
                      codex)
                        caddie_completion_register "$module_name" "codex:info codex:review codex:review:watch codex:review:watch:stop codex:review:watch:status codex:review:tail codex:review:command:set codex:review:command:get codex:review:command:unset"
                        ;;
                      core)
                        caddie_completion_register "$module_name" "core:info core:status core:set:home core:set:app core:get:app core:help core:aliases core:alias:grep core:alias:git core:alias:docker core:alias:npm core:alias:nav core:lint core:lint:limit"
                        ;;
                      cursor)
                        caddie_completion_register "$module_name" "cursor:info cursor:open cursor:new cursor:switch cursor:ai:explain cursor:ai:refactor cursor:ai:test cursor:ai:docs cursor:ai:review cursor:ext:install cursor:ext:recommend cursor:config:restore"
                        ;;
                      cross)
                        caddie_completion_register "$module_name" "cross:info cross:template:create cross:template:list cross:deploy:docker cross:deploy:local cross:deploy:railway"
                        ;;
                      git)
                        caddie_completion_register "$module_name" "git:status git:info git:branch git:branch:new git:branch:create git:branch:new:feature git:branch:new:bugfix git:branch:new:description git:commit git:gacp git:auth:login git:pr:create git:pr:approve git:push git:push:set:upstream git:pull git:merge:main git:branch:merge:main git:clone git:remote:add git:remote:set-url git:remote:list git:remote:remove git:worktree:list git:worktree:add git:worktree:remove git:worktree:prune git:worktree:lock git:worktree:unlock git:worktree:cd"
                        ;;
                      github)
                        caddie_completion_register "$module_name" "github:info github:account:set github:account:get github:account:unset github:auth:check github:repo:create github:repo:url"
                        ;;
                      cli)
                        caddie_completion_register "$module_name" "cli:info cli:red cli:green cli:yellow cli:blue cli:purple cli:cyan cli:grey cli:orange cli:white cli:red:bold cli:green:bold cli:yellow:bold cli:blue:bold cli:purple:bold cli:cyan:bold cli:grey:bold cli:orange:bold cli:white:bold cli:usage cli:installed cli:complete cli:title cli:colorlist cli:check cli:x cli:arrow cli:folder cli:beer cli:snake cli:crab cli:trash cli:rotate cli:chart cli:magnify cli:save cli:warning cli:debug cli:wrench cli:whale cli:package cli:git cli:rocket cli:thought cli:lightbulb cli:magnifying_glass cli:blank cli:indent cli:help"
                        ;;
                      debug)
                        caddie_completion_register "$module_name" "debug:info debug:on debug:off debug:status debug:help"
                        ;;
                    esac
                fi
            fi
        done
        return 0
    else
        # NOTE: Using printf instead of caddie cli:warning because the CLI module
        # hasn't been loaded yet (this function runs before module loading).
        # The caddie cli: functions are defined in .caddie_cli module which is only
        # available after the modules directory exists and modules are sourced.
        printf "Warning: Installation Error: The modules directory for caddie is not found. Please reinstall caddie.\n" >&2
        return 1
    fi
}

# Load all modules
_caddie_load_modules

# Restore bash completion hook now that all modules are loaded
if [[ $- == *i* ]] && command -v complete >/dev/null 2>&1; then
    complete -F _caddie_completion -o default -o nospace caddie
fi

# Caddie is now ready to use! (not shown during sourcing to avoid history pollution)
