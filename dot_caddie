#!/bin/bash

# Caddie.sh - Main Entry Point
# This file sources all the modular components and provides the main interface

# Exit immediately on any error for robust error handling
set -e

# Source the dependent files
# shellcheck disable=SC1091
source "$HOME/.caddie_version"
# shellcheck disable=SC1091
source "$HOME/.caddie_prompt.sh"
# shellcheck disable=SC1091
source "$HOME/.caddie_git"

# Auto-discover caddie modules from ~/.caddie_modules/ directory
# Each module file should have functions named <module>_caddie_register and <module>_help_register
CADDIE_MODULES_DIR="$HOME/.caddie_modules"

# Source data structure files
# shellcheck disable=SC1091
source "$HOME/.caddie_data/.caddie_commands"
# shellcheck disable=SC1091
source "$HOME/.caddie_data/.caddie_help"

# Helper function to extract module name from filename
function caddie_extract_module_name() {
    local filename="$1"
    basename "$filename" | sed 's/^\.caddie_//'
}

# Load all modules and register them
if [ -d "$CADDIE_MODULES_DIR" ]; then
    # Reset arrays before loading
    caddie_commands_reset
    caddie_help_reset
    
    # Use find with while read for better robustness (handles spaces in filenames)
    find "$CADDIE_MODULES_DIR" -name ".caddie_*" -type f -print0 2>/dev/null | while IFS= read -r -d '' module_file; do
        if [ -f "$module_file" ]; then
            # Extract module name from filename
            local module
            module=$(caddie_extract_module_name "$module_file")
            
            echo "Loading module: $module"
            # shellcheck disable=SC1090
            source "$module_file"
            
            # Call the module's register function
            if command -v "${module}_register" >/dev/null 2>&1; then
                echo "  ✓ Registered $module module"
                "${module}_register"
            else
                echo "  ⚠ Module $module missing register function"
            fi
        fi
    done
else
    echo "Warning: ~/.caddie_modules directory not found"
fi

# Commands are now discovered during module loading, no need for separate discovery loop

# Function to display caddie help
function caddie_help() {
    echo "Caddie.sh - Development Environment Manager"
    echo "=========================================="
    echo ""
    echo "Usage: caddie <command>"
    echo ""
    echo "Command Categories:"
    echo "  home                     Home directory management"
    
    # Display the loaded modules help information
    local loaded_modules
    loaded_modules=$(caddie_help_get)

    if [ -n "$loaded_modules" ]; then
        echo "Available modules:"
        for help_info in $loaded_modules; do
            echo "$help_info" | sed 's/^/  /;s/|/ - /'
        done
    fi
    
    echo
    echo "General Commands:"
    echo "  help                     Show this overview"
    echo "  version                  Show caddie version"
    echo
    echo "Detailed Help:"
    echo "  Use 'caddie <module>:help' for detailed information on any module"
    echo
}

# Main caddie function - directly executes commands
function caddie() {
    local command="$1"
    shift 2>/dev/null || true  # Remove first argument, handle case where no args
    
    # Handle built-in commands first
    case "$command" in
        "help"|"--help"|"-h")
            caddie_help
            return 0
            ;;
        "version"|"--version"|"-v")
            caddie_version
            return 0
            ;;
        "")
            caddie_help
            return 0
            ;;
    esac
    
    # Try to find and execute the command from registered commands
    local found=false

    for cmd_info in $(caddie_commands_get); do
        # Extract the command pattern (module:command) and function name
        local cmd_pattern
        local func_name
        cmd_pattern=$(echo "$cmd_info" | cut -d'|' -f1)
        func_name=$(echo "$cmd_info" | cut -d'|' -f2)
        
        if [ "$cmd_pattern" = "$command" ]; then
            # Found the command, execute it with remaining arguments
            if [ -n "$func_name" ] && command -v "$func_name" >/dev/null 2>&1; then
                eval "$func_name \"\$@\""
                found=true
                break
            else
                echo "Error: Function '$func_name' not found for command '$command'"
                return 1
            fi
        fi
    done
    
    if [ "$found" = false ]; then
        echo "Error: Unknown command '$command'"
        echo "Use 'caddie help' to see available commands"
        return 1
    fi
}



# Tab completion function for caddie command
function _caddie_completion() {
    local cur prev opts
    COMPREPLY=()
    
    # Safely access COMP_WORDS array elements
    if [ -n "$COMP_CWORD" ] && [ "${COMP_CWORD}" -ge 0 ] && [ "${COMP_CWORD}" -lt ${#COMP_WORDS[@]} ]; then
        cur="${COMP_WORDS[COMP_CWORD]}"
    else
        cur=""
    fi
    
    if [ -n "$COMP_CWORD" ] && [ "${COMP_CWORD}" -ge 1 ] && [ "${COMP_CWORD}" -lt ${#COMP_WORDS[@]} ]; then
        prev="${COMP_WORDS[COMP_CWORD-1]}"
    else
        prev=""
    fi
    
    # Build available caddie commands dynamically from discovered commands
    local opts="help version --help -h --version -v"

    for cmd_info in $(caddie_commands_get); do
        # Extract just the command pattern (module:command) for completion
        local cmd_pattern
        cmd_pattern=$(echo "$cmd_info" | cut -d'|' -f1)
        if [ -n "$cmd_pattern" ]; then
            opts="$opts $cmd_pattern"
        fi
    done
    
    # If we're completing the first argument (command)
    if [ -n "$COMP_CWORD" ] && [ "${COMP_CWORD}" -eq 1 ]; then
        # Use compgen to generate completions from our options
        local IFS=$'\n'
        mapfile -t COMPREPLY < <(compgen -W "${opts}" -- "${cur}")
        return 0
    fi
    
    # Handle completion for specific commands that take arguments
    case "${prev}" in
        "core:set:home")
            # Complete with directory names
            mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
            return 0
            ;;
        "python:create"|"python:activate"|"python:remove")
            # Complete with existing virtual environment names
            if [ -d "$HOME/.virtualenvs" ]; then
                local venvs
                venvs=$(ls "$HOME/.virtualenvs" 2>/dev/null)
                mapfile -t COMPREPLY < <(compgen -W "${venvs}" -- "${cur}")
            fi
            return 0
            ;;
        "python:install"|"python:uninstall"|"python:upgrade")
            # Complete with installed packages (if pip is available)
            if command -v pip >/dev/null 2>&1; then
                local packages
                packages=$(pip list --format=freeze 2>/dev/null | cut -d'=' -f1)
                mapfile -t COMPREPLY < <(compgen -W "${packages}" -- "${cur}")
            fi
            return 0
            ;;
        "rust:new")
            # Complete with directory names for project location
            mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
            return 0
            ;;
        "rust:add"|"rust:remove")
            # Complete with installed crates (if cargo is available)
            if [ -f "Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
                local crates
                crates=$(grep -E '^[[:space:]]*[a-zA-Z0-9_-]+[[:space:]]*=' Cargo.toml 2>/dev/null | sed 's/[[:space:]]*\([a-zA-Z0-9_-]*\)[[:space:]]*=.*/\1/')
                mapfile -t COMPREPLY < <(compgen -W "${crates}" -- "${cur}")
            fi
            return 0
            ;;
        "rust:toolchain")
            # Complete with common Rust toolchain versions
            local toolchains="stable beta nightly"
            mapfile -t COMPREPLY < <(compgen -W "${toolchains}" -- "${cur}")
            return 0
            ;;
        "rust:target")
            # Complete with common Rust targets
            local targets="x86_64-unknown-linux-gnu aarch64-apple-darwin x86_64-apple-darwin x86_64-pc-windows-msvc"
            mapfile -t COMPREPLY < <(compgen -W "${targets}" -- "${cur}")
            return 0
            ;;
        "rust:component")
            # Complete with common Rust components
            local components="clippy rustfmt rust-src rust-analysis"
            mapfile -t COMPREPLY < <(compgen -W "${components}" -- "${cur}")
            return 0
            ;;
        "cross:template:create")
            # Complete with available template types
            local templates="web cli api data ml lib wasm app framework extension mobile"
            mapfile -t COMPREPLY < <(compgen -W "${templates}" -- "${cur}")
            return 0
            ;;
        # Cursor integration completions
        "cursor:open")
            # Complete with directory names
            mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
            return 0
            ;;
        "cursor:new")
            # Complete with project types
            local project_types="web api mobile data ml cli lib"
            mapfile -t COMPREPLY < <(compgen -W "${project_types}" -- "${cur}")
            return 0
            ;;
        "cursor:switch")
            # Complete with recent projects and common project directories
            local projects=""
            # Add recent projects from Cursor workspace storage
            if [ -d "$HOME/.cursor/User/workspaceStorage" ]; then
                projects=$(find "$HOME/.cursor/User/workspaceStorage" -name "*.json" -exec basename {} \; 2>/dev/null | sed 's/\.json$//')
            fi
            # Add common project directories
            if [ -d "$HOME/projects" ]; then
                projects="$projects $(ls "$HOME/projects" 2>/dev/null)"
            fi
            if [ -d "$HOME/work" ]; then
                projects="$projects $(ls "$HOME/work" 2>/dev/null)"
            fi
            mapfile -t COMPREPLY < <(compgen -W "${projects}" -- "${cur}")
            return 0
            ;;
        "cursor:ai:explain"|"cursor:ai:refactor"|"cursor:ai:test"|"cursor:ai:docs"|"cursor:ai:review")
            # Complete with file names
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
        "cursor:ext:install")
            # Complete with common extension IDs
            local common_extensions="ms-python.python ms-python.pylint ms-python.black-formatter rust-lang.rust-analyzer ms-vscode.vscode-typescript-next esbenp.prettier-vscode ms-vscode.vscode-eslint ms-vscode.vscode-json redhat.vscode-yaml ms-vscode.vscode-markdown"
            mapfile -t COMPREPLY < <(compgen -W "${common_extensions}" -- "${cur}")
            return 0
            ;;
        "cursor:ext:recommend")
            # Complete with project types
            local project_types="python rust javascript typescript web mobile data ml"
            mapfile -t COMPREPLY < <(compgen -W "${project_types}" -- "${cur}")
            return 0
            ;;
        "cursor:config:restore")
            # Complete with backup directories
            if [ -d "$HOME/.cursor-backups" ]; then
                local backups
                backups=$(ls "$HOME/.cursor-backups" 2>/dev/null)
                mapfile -t COMPREPLY < <(compgen -W "${backups}" -- "${cur}")
            fi
            return 0
            ;;
    esac
    
    # Handle multi-argument commands
    local first_arg=""
    if [ ${#COMP_WORDS[@]} -ge 2 ]; then
        first_arg="${COMP_WORDS[1]}"
    fi
    case "${first_arg}" in
        "cursor:new")
            # First argument is project type, second is project name
            if [ "${COMP_CWORD}" -eq 2 ]; then
                local project_types="web api mobile data ml cli lib"
                mapfile -t COMPREPLY < <(compgen -W "${project_types}" -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                # Complete with directory names for project location
                mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:refactor")
            # First argument is file, second is refactor type
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local refactor_types="general performance readability security structure"
                mapfile -t COMPREPLY < <(compgen -W "${refactor_types}" -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:test")
            # First argument is file, second is test framework
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local test_frameworks="pytest unittest jest mocha rspec"
                mapfile -t COMPREPLY < <(compgen -W "${test_frameworks}" -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:docs")
            # First argument is file, second is doc format
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local doc_formats="markdown sphinx javadoc godoc rustdoc"
                mapfile -t COMPREPLY < <(compgen -W "${doc_formats}" -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:review")
            # First argument is file, second is review focus
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local review_focus="general security performance style bugs best-practices"
                mapfile -t COMPREPLY < <(compgen -W "${review_focus}" -- "${cur}")
                return 0
            fi
            ;;
    esac
    
    return 0
}

# Export the caddie function and helper functions so they're available in subshells
export -f caddie
export -f caddie_help
export -f caddie_extract_module_name

# Set up tab completion if available (bash 4.0+)
if command -v complete >/dev/null 2>&1; then
    # Clear any existing completion for caddie and register our completion function
    complete -r caddie 2>/dev/null || true
    complete -F _caddie_completion caddie
    export -f _caddie_completion
    echo "  ✓ Tab completion enabled"
else
    echo "  ⚠ Tab completion not available (bash 3.2 detected)"
fi

# Caddie is now ready to use!
echo "✓ Caddie.sh loaded successfully with all modules"
