#!/bin/bash

# Caddie.sh - Main Entry Point
# This file sources all the modular components and provides the main interface

# Define caddie modules and their descriptions.
# Each entry should be in the format "key:Description", where:
#   - key:     The module name (used for sourcing ~/.caddie_<key>)
#   - Description: A human-readable description for help output.
# Example: "rust:Rust development tools" means the module "rust" will be loaded from ~/.caddie_rust,
#          and its description will be shown in help listings.
CADDIE_MODULES=(
    "core:Core caddie functions"
    "python:Python environment management"
    "rust:Rust development tools"
    "ios:iOS development tools"
    "cross:Cross-language features"
    "cursor:Cursor IDE integration"
)

CADDIE_MODULE_HELP=""
for moddesc in "${CADDIE_MODULES[@]}"; do
    module="${moddesc%%:*}"
    desc="${moddesc#*:}"
    file="$HOME/.caddie_${module}"
    if [ -f "$file" ]; then
        source "$file"
        CADDIE_MODULE_HELP="${CADDIE_MODULE_HELP}  ${module} -${desc}\n"
    else
        echo "Warning: ${desc} module not found at $file"
    fi
done
# Note: CADDIE_MODULE_HELP is now used in the help function to dynamically show loaded modules

# Discover all available commands from all modules
CADDIE_COMMANDS=()
for moddesc in "${CADDIE_MODULES[@]}"; do
    module="${moddesc%%:*}"
    if [ -n "$module" ]; then
        # Call module's registration function to get its commands
        if command -v "${module}_caddie_register" >/dev/null 2>&1; then
            while IFS= read -r cmd_info; do
                if [ -n "$cmd_info" ]; then
                    CADDIE_COMMANDS+=("$cmd_info")
                fi
            done < <("${module}_caddie_register")
        fi
    fi
done

# Main caddie function - dynamically routes commands to modules
caddie() {
    local command="$1"
    local args=("$@")
    

    
    # Try to route to a module using dynamic command discovery
    for cmd_info in "${CADDIE_COMMANDS[@]}"; do
        # Parse the format: "module:command:function:description" or "command:function:description"
        local first_colon="${cmd_info%%:*}"
        local after_first="${cmd_info#*:}"
        local second_colon="${after_first%%:*}"
        local after_second="${after_first#*:}"
        local third_colon="${after_second%%:*}"
        
        # Check if this is a module:command:function:description format
        if [[ "$after_second" == *:* ]]; then
            # New format: "module:command:function:description"
            local module="$first_colon"
            # The command part is everything between module and function
            local temp_after_module="${cmd_info#*:}"
            local temp_before_func="${temp_after_module%:*}"
            local func_name="${temp_before_func##*:}"
            local cmd_part="${temp_before_func%:*}"
            local description="${after_second#*:}"
            local cmd_pattern="${module}:${cmd_part}"
        else
            # Old format: "command:function:description"
            local module=""
            local cmd_part="$first_colon"
            local func_name="$second_colon"
            local description="$after_second"
            local cmd_pattern="$cmd_part"
        fi
        
        if [ "$command" = "$cmd_pattern" ]; then
            # Call the module's function with remaining arguments
            # Remove the first argument (the command) and pass the rest
            local remaining_args=("${args[@]:1}")
            eval "${func_name} \"\${remaining_args[@]}\""
            return 0
        fi
    done
    
    # Handle core commands and errors
    case "$command" in
        "help"|"--help"|"-h")
            caddie_help
            ;;
        "version"|"--version"|"-v")
            caddie_version
            ;;
        "")
            echo "Caddie.sh - Development Environment Manager"
            echo "Use 'caddie help' for available commands"
            ;;
        *)
            echo "Error: Unknown command '$command'"
            echo "Use 'caddie help' for available commands"
            return 1
            ;;
    esac
}

# Tab completion function for caddie command
_caddie_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Build available caddie commands dynamically from discovered commands
    local opts="help version --help -h --version -v"
    for cmd_info in "${CADDIE_COMMANDS[@]}"; do
        # Parse the format: "module:command:function:description" or "command:function:description"
        local first_colon="${cmd_info%%:*}"
        local after_first="${cmd_info#*:}"
        local second_colon="${after_first%%:*}"
        local after_second="${after_first#*:}"
        local third_colon="${after_second%%:*}"
        
        # Check if this is a module:command:function:description format
        if [[ "$after_second" == *:* ]]; then
            # New format: "module:command:function:description"
            local module="$first_colon"
            # The command part is everything between module and function
            local temp_after_module="${cmd_info#*:}"
            local temp_before_func="${temp_after_module%:*}"
            local func_name="${temp_before_func##*:}"
            local cmd_part="${temp_before_func%:*}"
            local description="${after_second#*:}"
            local cmd_pattern="${module}:${cmd_part}"
        else
            # Old format: "command:function:description"
            local module=""
            local cmd_part="$first_colon"
            local func_name="$second_colon"
            local description="$after_second"
            local cmd_pattern="$cmd_part"
        fi
        
        if [ -n "$cmd_pattern" ]; then
            opts="$opts $cmd_pattern"
        fi
    done
    
    # If we're completing the first argument (command)
    if [ ${COMP_CWORD} -eq 1 ]; then
        # Use compgen to generate completions from our options
        local IFS=$'\n'
        COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
        return 0
    fi
    
    # Handle completion for specific commands that take arguments
    case "${prev}" in
        "core:set:home")
            # Complete with directory names
            COMPREPLY=( $(compgen -d -- "${cur}") )
            return 0
            ;;
        "python:create"|"python:activate"|"python:remove")
            # Complete with existing virtual environment names
            if [ -d "$HOME/.virtualenvs" ]; then
                local venvs=$(ls "$HOME/.virtualenvs" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${venvs}" -- "${cur}") )
            fi
            return 0
            ;;
        "python:install"|"python:uninstall"|"python:upgrade")
            # Complete with installed packages (if pip is available)
            if command -v pip >/dev/null 2>&1; then
                local packages=$(pip list --format=freeze 2>/dev/null | cut -d'=' -f1)
                COMPREPLY=( $(compgen -W "${packages}" -- "${cur}") )
            fi
            return 0
            ;;
        "rust:new")
            # Complete with directory names for project location
            COMPREPLY=( $(compgen -d -- "${cur}") )
            return 0
            ;;
        "rust:add"|"rust:remove")
            # Complete with installed crates (if cargo is available)
            if [ -f "Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
                local crates=$(grep -E '^[[:space:]]*[a-zA-Z0-9_-]+[[:space:]]*=' Cargo.toml 2>/dev/null | sed 's/[[:space:]]*\([a-zA-Z0-9_-]*\)[[:space:]]*=.*/\1/')
                COMPREPLY=( $(compgen -W "${crates}" -- "${cur}") )
            fi
            return 0
            ;;
        "rust:toolchain")
            # Complete with common Rust toolchain versions
            local toolchains="stable beta nightly"
            COMPREPLY=( $(compgen -W "${toolchains}" -- "${cur}") )
            return 0
            ;;
        "rust:target")
            # Complete with common Rust targets
            local targets="x86_64-unknown-linux-gnu aarch64-apple-darwin x86_64-apple-darwin x86_64-pc-windows-msvc"
            COMPREPLY=( $(compgen -W "${targets}" -- "${cur}") )
            return 0
            ;;
        "rust:component")
            # Complete with common Rust components
            local components="clippy rustfmt rust-src rust-analysis"
            COMPREPLY=( $(compgen -W "${components}" -- "${cur}") )
            return 0
            ;;
        "cross:template:create")
            # Complete with available template types
            local templates="web cli api data ml lib wasm app framework extension mobile"
            COMPREPLY=( $(compgen -W "${templates}" -- "${cur}") )
            return 0
            ;;
        # Cursor integration completions
        "cursor:open")
            # Complete with directory names
            COMPREPLY=( $(compgen -d -- "${cur}") )
            return 0
            ;;
        "cursor:new")
            # Complete with project types
            local project_types="web api mobile data ml cli lib"
            COMPREPLY=( $(compgen -W "${project_types}" -- "${cur}") )
            return 0
            ;;
        "cursor:switch")
            # Complete with recent projects and common project directories
            local projects=""
            # Add recent projects from Cursor workspace storage
            if [ -d "$HOME/.cursor/User/workspaceStorage" ]; then
                projects=$(find "$HOME/.cursor/User/workspaceStorage" -name "*.json" -exec basename {} \; 2>/dev/null | sed 's/\.json$//')
            fi
            # Add common project directories
            if [ -d "$HOME/projects" ]; then
                projects="$projects $(ls "$HOME/projects" 2>/dev/null)"
            fi
            if [ -d "$HOME/work" ]; then
                projects="$projects $(ls "$HOME/work" 2>/dev/null)"
            fi
            COMPREPLY=( $(compgen -W "${projects}" -- "${cur}") )
            return 0
            ;;
        "cursor:ai:explain"|"cursor:ai:refactor"|"cursor:ai:test"|"cursor:ai:docs"|"cursor:ai:review")
            # Complete with file names
            COMPREPLY=( $(compgen -f -- "${cur}") )
            return 0
            ;;
        "cursor:ext:install")
            # Complete with common extension IDs
            local common_extensions="ms-python.python ms-python.pylint ms-python.black-formatter rust-lang.rust-analyzer ms-vscode.vscode-typescript-next esbenp.prettier-vscode ms-vscode.vscode-eslint ms-vscode.vscode-json redhat.vscode-yaml ms-vscode.vscode-markdown"
            COMPREPLY=( $(compgen -W "${common_extensions}" -- "${cur}") )
            return 0
            ;;
        "cursor:ext:recommend")
            # Complete with project types
            local project_types="python rust javascript typescript web mobile data ml"
            COMPREPLY=( $(compgen -W "${project_types}" -- "${cur}") )
            return 0
            ;;
        "cursor:config:restore")
            # Complete with backup directories
            if [ -d "$HOME/.cursor-backups" ]; then
                local backups=$(ls "$HOME/.cursor-backups" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${backups}" -- "${cur}") )
            fi
            return 0
            ;;
    esac
    
    # Handle multi-argument commands
    case "${COMP_WORDS[1]}" in
        "cursor:new")
            # First argument is project type, second is project name
            if [ ${COMP_CWORD} -eq 2 ]; then
                local project_types="web api mobile data ml cli lib"
                COMPREPLY=( $(compgen -W "${project_types}" -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                # Complete with directory names for project location
                COMPREPLY=( $(compgen -d -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:refactor")
            # First argument is file, second is refactor type
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local refactor_types="general performance readability security structure"
                COMPREPLY=( $(compgen -W "${refactor_types}" -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:test")
            # First argument is file, second is test framework
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local test_frameworks="pytest unittest jest mocha rspec"
                COMPREPLY=( $(compgen -W "${test_frameworks}" -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:docs")
            # First argument is file, second is doc format
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local doc_formats="markdown sphinx javadoc godoc rustdoc"
                COMPREPLY=( $(compgen -W "${doc_formats}" -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:review")
            # First argument is file, second is review focus
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local review_focus="general security performance style bugs best-practices"
                COMPREPLY=( $(compgen -W "${review_focus}" -- "${cur}") )
                return 0
            fi
            ;;
    esac
    
    return 0
}

# Clear any existing completion for caddie and register our completion function
complete -r caddie 2>/dev/null || true
complete -F _caddie_completion caddie

# Export the caddie function so it's available in subshells
export -f caddie
export -f _caddie_completion

# Caddie is now ready to use!
echo "âœ“ Caddie.sh loaded successfully with all modules"
