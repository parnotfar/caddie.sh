#!/bin/bash

source "$HOME/.caddie_modules/.caddie_core"

# Function to display caddie help
function caddie_help() {
    caddie cli:title "Caddie.sh - Development Environment Manager"
    caddie cli:blank
    
    caddie cli:usage "caddie <command>"
    caddie cli:blank
    
    caddie cli:title "Command Categories:"
    caddie cli:indent "home                     Home directory management"
    caddie cli:indent "aliases                  Alias search and management"
    
    caddie cli:title "Navigation:"
    caddie cli:indent "go:home                  Navigate to caddie home directory"
    
    caddie cli:title "Available modules:"
    for m in $(caddie_modules_get); do
        description_function="caddie_${m}_description"
        printf "  %-10s %s\n" "$m" "$(eval "$description_function")"
    done
    
    caddie cli:blank
    caddie cli:title "General Commands:"
    caddie cli:indent "help                     Show this overview"
    caddie cli:indent "version                  Show caddie version"
    caddie cli:indent "reload                   Reload caddie"
    caddie cli:blank
    caddie cli:title "Productivity:"
    caddie cli:indent "core:aliases             Show all available aliases"
    caddie cli:blank
    caddie cli:title "Detailed Help:"
    caddie cli:indent "Use 'caddie <module>:help' for detailed information on any module"
    caddie cli:blank
}

# Function to show caddie version
function caddie_version() {
    if [ -f "$HOME/.caddie_version" ]; then
        source "$HOME/.caddie_version"
        caddie cli:package "Caddie.sh version: $CADDIE_SH_VERSION"
    else
        caddie cli:warning "Caddie.sh version: unknown"
    fi
}

# Main caddie function - directly executes commands
function caddie() {
    local command="$1"

    shift  # Remove first argument (the command)

    # Handle built-in commands first
    case "$command" in
        "help"|"--help"|"-h")
            caddie_help
            return 0
            ;;
        "version"|"--version"|"-v")
            caddie_version
            return 0
            ;;
        "reload"|"--reload"|"-r")
            source "$HOME/.bash_profile"
            return 0
            ;;
        "")
            caddie_help
            return 0
            ;;
    esac
    
    # Handle special case: go:home command
    if [[ "$command" == "go:home" ]]; then
        caddie_core_go_home "$@"
        return 0
    fi
    
    # Use naming convention: module:command -> caddie_module_command
    local function_name="caddie_${command//:/_}"
    
    if command -v "$function_name" >/dev/null 2>&1; then
        eval "$function_name \"\$@\""
    else
        echo "Error: Unknown command '$command'"
        caddie_help
        return 1
    fi
}

# --- completion setup ---
# 1) make ':' not break words (so ruby:add stays one token)
COMP_WORDBREAKS=${COMP_WORDBREAKS//:/}

_caddie_completion() {
  local cur prev words cword
  COMPREPLY=()

  # Prefer bash-completion helper if present; otherwise manual
  if declare -F _get_comp_words_by_ref >/dev/null 2>&1; then
    _get_comp_words_by_ref -n : cur prev words cword
  else
    words=("${COMP_WORDS[@]}")
    cword=${COMP_CWORD:-0}
    cur=${words[$cword]}
    prev=${words[$((cword-1))]}
  fi

  # Build a flat list of all accepted commands
  local base_opts="help version go:home --help -h --version -v reload --reload -r"
  local modules=()
  
  if command -v caddie_modules_get >/dev/null 2>&1; then
    # read safely into array; suppress module function's stdout noise
    IFS=$'\n' read -r -d '' -a modules < <(caddie_modules_get 2>/dev/null; printf '\0')
  fi
  
  # Add module-specific commands (these are the actual commands, not subcommands)
  local module_commands=""
  for module in "${modules[@]}"; do
    case "$module" in
      python)
        module_commands="$module_commands python:init python:install python:update python:venv:activate python:venv:deactivate python:build python:test python:run python:lint python:format python:pip:freeze python:pip:audit"
        ;;
      ruby)
        module_commands="$module_commands ruby:init ruby:bundle ruby:install ruby:update ruby:exec ruby:rake ruby:rspec ruby:rubocop"
        ;;
      js)
        module_commands="$module_commands js:init js:install js:add js:update js:build js:dev js:start js:test js:lint js:format js:audit"
        ;;
      rust)
        module_commands="$module_commands rust:init rust:new rust:build rust:run rust:run:example rust:test rust:test:unit rust:test:integration rust:test:all rust:test:property rust:test:bench rust:test:watch rust:test:coverage rust:add rust:remove rust:fmt rust:clippy rust:check rust:clean rust:update rust:search rust:outdated rust:audit rust:toolchain rust:target rust:component rust:git:status rust:gitignore rust:git:clean"
        ;;
      ios)
        module_commands="$module_commands ios:build ios:run ios:test ios:archive ios:pods:install ios:swift:version ios:rust:setup"
        ;;
      core)
        module_commands="$module_commands core:status core:set:home core:set:app core:get:app core:help core:aliases core:alias:grep core:alias:git core:alias:docker core:alias:npm core:alias:nav core:lint core:lint:limit"
        ;;
      cursor)
        module_commands="$module_commands cursor:open cursor:new cursor:switch cursor:ai:explain cursor:ai:refactor cursor:ai:test cursor:ai:docs cursor:ai:review cursor:ext:install cursor:ext:recommend cursor:config:restore"
        ;;
      cross)
        module_commands="$module_commands cross:template:create"
        ;;
      git)
        module_commands="$module_commands git:status git:branch git:new:branch git:commit git:gacp git:auth:login git:pr:create git:push git:push:set:upstream git:pull git:clone git:remote:add git:remote:set-url git:remote:list git:remote:remove"
        ;;
      github)
        module_commands="$module_commands github:account:set github:account:get github:account:unset github:auth:check github:repo:create github:repo:url"
        ;;
      csv)
        module_commands="$module_commands csv:init csv:query csv:scatter csv:list \
csv:set:file csv:get:file csv:unset:file \
csv:set:x csv:get:x csv:unset:x \
csv:set:y csv:get:y csv:unset:y \
csv:set:sep csv:get:sep csv:unset:sep \
csv:set:plot csv:get:plot csv:unset:plot \
csv:set:title csv:get:title csv:unset:title \
csv:set:limit csv:get:limit csv:unset:limit \
csv:set:save csv:get:save csv:unset:save \
csv:set:success_filter csv:get:success_filter csv:unset:success_filter \
csv:set:scatter_filter csv:get:scatter_filter csv:unset:scatter_filter \
csv:set:sql csv:get:sql csv:unset:sql \
csv:set:circle csv:get:circle csv:unset:circle \
csv:set:rings csv:get:rings csv:unset:rings \
csv:set:circle_x csv:get:circle_x csv:unset:circle_x \
csv:set:circle_y csv:get:circle_y csv:unset:circle_y \
csv:set:circle_r csv:get:circle_r csv:unset:circle_r \
csv:set:circle_radii csv:get:circle_radii csv:unset:circle_radii"
        ;;
      cli)
        module_commands="$module_commands cli:red cli:green cli:yellow cli:blue cli:purple cli:cyan cli:grey cli:orange cli:white cli:red:bold cli:green:bold cli:yellow:bold cli:blue:bold cli:purple:bold cli:cyan:bold cli:grey:bold cli:orange:bold cli:white:bold cli:usage cli:installed cli:complete cli:title cli:colorlist cli:check cli:x cli:arrow cli:folder cli:beer cli:snake cli:crab cli:trash cli:rotate cli:chart cli:magnify cli:save cli:warning cli:debug cli:wrench cli:whale cli:package cli:git cli:rocket cli:thought cli:lightbulb cli:magnifying_glass cli:blank cli:indent cli:help"
        ;;
      debug)
        module_commands="$module_commands debug:on debug:off debug:status debug:help"
        ;;
    esac
  done
  
  local all_opts="$base_opts $module_commands"
  
  # Complete with all available commands
  IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$all_opts" -- "$cur")
  
  # If we have multiple completions and the current word contains a colon,
  # try to provide more specific completions for subcommands
  if [[ ${#COMPREPLY[@]} -gt 1 && "$cur" == *:* ]]; then
    # Extract the prefix (everything before the last colon)
    local prefix="${cur%:*}"
    local subcommand_prefix="$prefix:"
    
    # Filter completions to only show those that start with the subcommand prefix
    local filtered_completions=()
    for completion in "${COMPREPLY[@]}"; do
      if [[ "$completion" == "$subcommand_prefix"* ]]; then
        filtered_completions+=("$completion")
      fi
    done
    
    # If we found filtered completions, use them
    if [[ ${#filtered_completions[@]} -gt 0 ]]; then
      COMPREPLY=("${filtered_completions[@]}")
    fi
  fi
  
  return 0
}

# Helper function to extract module name from filename
function caddie_extract_module_name() {
    local filename="$1"
    basename "$filename" | sed 's/^\.caddie_//'
}

# Export the caddie function and helper functions so they're available in subshells
export -f caddie
export -f caddie_help
export -f caddie_version

# Source the dependent files
source "$HOME/.caddie_version"
source "$HOME/.caddie_prompt.sh"

# Source data structure files
source "$HOME/.caddie_data/.caddie_modules"

# Auto-discover caddie modules from ~/.caddie_modules/ directory
# Each module file should have functions named <module>_caddie_description and <module>_caddie_help
CADDIE_MODULES_DIR="$HOME/.caddie_modules"

# Load all modules 
if [ -d "$CADDIE_MODULES_DIR" ]; then
    # Reset modules array before loading
    caddie_modules_reset

    # Load all modules and populate modules array
    while IFS= read -r -d '' file; do
        source "$file"
        caddie_modules_append "$(caddie_extract_module_name "$file")"
    done < <(find "$CADDIE_MODULES_DIR" -name ".caddie_*" -type f -print0 2>/dev/null)
else
    caddie cli:warning "Installation Error: The modules directory for caddie is not found.  Please reinstall caddie."
    return 1
fi

# Set up tab completion
if command -v complete >/dev/null 2>&1; then
    # Clear any existing completion for caddie and register our completion function
    complete -r caddie 2>/dev/null || true
    complete -o default -F _caddie_completion caddie
    
    # Configure completion behavior
    bind 'set show-all-if-ambiguous off' 2>/dev/null || true
    bind 'set show-all-if-unmodified off' 2>/dev/null || true
    bind 'set completion-ignore-case off' 2>/dev/null || true
    
    caddie cli:check "Tab completion enabled"
else
    caddie cli:warning "Tab completion not available"
fi

# Caddie is now ready to use!
caddie cli:check "Caddie.sh loaded successfully"
