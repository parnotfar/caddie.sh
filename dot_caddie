#!/bin/bash

# Caddie.sh - Main Entry Point
# This file sources all the modular components and provides the main interface

# Note: set -e removed for better error handling and user experience
# Errors will be handled gracefully with proper error messages

# Source the dependent files
source "$HOME/.caddie_version" 2>/dev/null || true
source "$HOME/.caddie_prompt.sh" 2>/dev/null || true
source "$HOME/.caddie_git" 2>/dev/null || true
source "$HOME/.caddie_debug" 2>/dev/null || true

# Auto-discover caddie modules from ~/.caddie_modules/ directory
# Each module file should have functions named <module>_caddie_description and <module>_caddie_help
CADDIE_MODULES_DIR="$HOME/.caddie_modules"

# Source data structure files
source "$HOME/.caddie_data/.caddie_commands" 2>/dev/null || true
source "$HOME/.caddie_data/.caddie_help" 2>/dev/null || true
source "$HOME/.caddie_data/.caddie_modules" 2>/dev/null || true

# Helper function to extract module name from filename
function caddie_extract_module_name() {
    local filename="$1"
    basename "$filename" | sed 's/^\.caddie_//'
}

# Load all modules and register them
if [ -d "$CADDIE_MODULES_DIR" ]; then
    # Reset arrays before loading
    caddie_commands_reset
    caddie_help_reset
    
    caddie_debug "=== Starting module loading process ==="
    caddie_debug "CADDIE_MODULES_DIR: $CADDIE_MODULES_DIR"
    
    # Use a different approach to avoid subshell issues with while read
    # Store module files in an array first, then iterate
    module_files=()
    caddie_modules_reset

    while IFS= read -r -d '' file; do
        source "$file" 2>/dev/null || true
        module_name=$(caddie_extract_module_name "$file")
        module_files+=("$file")
        caddie_modules_append "$module_name"
    done < <(find "$CADDIE_MODULES_DIR" -name ".caddie_*" -type f -print0 2>/dev/null)
    
    caddie_debug "=== Module loading complete ==="
    caddie_debug "Final commands count: $(caddie_commands_count)"
    caddie_debug "Final help count: $(caddie_help_count)"
    caddie_debug "Final commands array contents: [$(caddie_commands_get)]"
    caddie_debug "Final help array contents: [$(caddie_help_get)]"
else
    echo "Warning: ~/.caddie_modules directory not found"
fi

# Commands are now discovered during module loading, no need for separate discovery loop

# Function to display caddie help
function caddie_help() {
    caddie_debug "=== caddie_help function called ==="
    caddie_debug "Current commands count: $(caddie_commands_count)"
    caddie_debug "Current help count: $(caddie_help_count)"
    
    echo "Caddie.sh - Development Environment Manager"
    echo "=========================================="
    echo ""
    echo "Usage: caddie <command>"
    echo ""
    echo "Command Categories:"
    echo "  home                     Home directory management"
    
    echo "Available modules:"
    for m in $(caddie_modules_get); do
        description_function="caddie_${m}_description"
        printf "  %-10s %s\n" "$m" "$(eval "$description_function")"
    done
    
    echo
    echo "General Commands:"
    echo "  help                     Show this overview"
    echo "  version                  Show caddie version"
    echo
    echo "Detailed Help:"
    echo "  Use 'caddie <module>:help' for detailed information on any module"
    echo
}

# Function to show caddie version
function caddie_version() {
    if [ -f "$HOME/.caddie_version" ]; then
        # shellcheck disable=SC1091
        source "$HOME/.caddie_version"
        echo "Caddie.sh version: $CADDIE_SH_VERSION"
    else
        echo "Caddie.sh version: unknown"
    fi
}

# Main caddie function - directly executes commands
function caddie() {
    local command="$1"

    shift  # Remove first argument (the command); safe in bash, no need for OPTIND here

    caddie_debug "=== caddie function called ==="
    caddie_debug "command='$command'"
    caddie_debug "remaining args='$*'"
    caddie_debug "Current commands count: $(caddie_commands_count)"
    caddie_debug "Current help count: $(caddie_help_count)"
    
    # Handle built-in commands first
    case "$command" in
        "help"|"--help"|"-h")
            caddie_help
            return 0
            ;;
        "version"|"--version"|"-v")
            caddie_version
            return 0
            ;;
        "")
            caddie_help
            return 0
            ;;
    esac
    
    # Use naming convention: module:command -> caddie_module_command
    local function_name="caddie_${command//:/_}"
    
    if command -v "$function_name" >/dev/null 2>&1; then
        caddie_debug "Found function '$function_name', executing with args: $*"
        eval "$function_name \"\$@\""
    else
        echo "Error: Unknown command '$command'"
        caddie_help
        return 1
    fi
}

# Tab completion function for caddie command
function _caddie_completion() {
    local cur prev opts

    COMPREPLY=()
    
    # Safely access COMP_WORDS array elements
    if [ -n "$COMP_CWORD" ] && [ "${COMP_CWORD}" -ge 0 ] && [ "${COMP_CWORD}" -lt ${#COMP_WORDS[@]} ]; then
        cur="${COMP_WORDS[COMP_CWORD]}"
    else
        cur=""
    fi
    
    if [ -n "$COMP_CWORD" ] && [ "${COMP_CWORD}" -ge 1 ] && [ "${COMP_CWORD}" -lt ${#COMP_WORDS[@]} ]; then
        prev="${COMP_WORDS[COMP_CWORD-1]}"
    else
        prev=""
    fi
    
    # Build available caddie commands dynamically from discovered commands
    local opts="help version --help -h --version -v"

    for cmd_info in $(caddie_commands_get); do
        # Extract just the command pattern (module:command) for completion
        local cmd_pattern
        cmd_pattern=$(echo "$cmd_info" | cut -d'|' -f1)
        if [ -n "$cmd_pattern" ]; then
            opts="$opts $cmd_pattern"
        fi
    done
    
    # If we're completing the first argument (command)
    if [ -n "$COMP_CWORD" ] && [ "${COMP_CWORD}" -eq 1 ]; then
        # Use compgen to generate completions from our options
        local IFS=$'\n'
        mapfile -t COMPREPLY < <(compgen -W "${opts}" -- "${cur}")
        return 0
    fi
    
    # Handle completion for specific commands that take arguments
    case "${prev}" in
        "core:set:home")
            # Complete with directory names
            mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
            return 0
            ;;
        "python:create"|"python:activate"|"python:remove")
            # Complete with existing virtual environment names
            if [ -d "$HOME/.virtualenvs" ]; then
                local venvs
                venvs=$(ls "$HOME/.virtualenvs" 2>/dev/null)
                mapfile -t COMPREPLY < <(compgen -W "${venvs}" -- "${cur}")
            fi
            return 0
            ;;
        "python:install"|"python:uninstall"|"python:upgrade")
            # Complete with installed packages (if pip is available)
            if command -v pip >/dev/null 2>&1; then
                local packages
                packages=$(pip list --format=freeze 2>/dev/null | cut -d'=' -f1)
                mapfile -t COMPREPLY < <(compgen -W "${packages}" -- "${cur}")
            fi
            return 0
            ;;
        "rust:new")
            # Complete with directory names for project location
            mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
            return 0
            ;;
        "rust:add"|"rust:remove")
            # Complete with installed crates (if cargo is available)
            if [ -f "Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
                local crates
                crates=$(grep -E '^[[:space:]]*[a-zA-Z0-9_-]+[[:space:]]*=' Cargo.toml 2>/dev/null | sed 's/[[:space:]]*\([a-zA-Z0-9_-]*\)[[:space:]]*=.*/\1/')
                mapfile -t COMPREPLY < <(compgen -W "${crates}" -- "${cur}")
            fi
            return 0
            ;;
        "rust:toolchain")
            # Complete with common Rust toolchain versions
            local toolchains="stable beta nightly"
            mapfile -t COMPREPLY < <(compgen -W "${toolchains}" -- "${cur}")
            return 0
            ;;
        "rust:target")
            # Complete with common Rust targets
            local targets="x86_64-unknown-linux-gnu aarch64-apple-darwin x86_64-apple-darwin x86_64-pc-windows-msvc"
            mapfile -t COMPREPLY < <(compgen -W "${targets}" -- "${cur}")
            return 0
            ;;
        "rust:component")
            # Complete with common Rust components
            local components="clippy rustfmt rust-src rust-analysis"
            mapfile -t COMPREPLY < <(compgen -W "${components}" -- "${cur}")
            return 0
            ;;
        "cross:template:create")
            # Complete with available template types
            local templates="web cli api data ml lib wasm app framework extension mobile"
            mapfile -t COMPREPLY < <(compgen -W "${templates}" -- "${cur}")
            return 0
            ;;
        # Cursor integration completions
        "cursor:open")
            # Complete with directory names
            mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
            return 0
            ;;
        "cursor:new")
            # Complete with project types
            local project_types="web api mobile data ml cli lib"
            mapfile -t COMPREPLY < <(compgen -W "${project_types}" -- "${cur}")
            return 0
            ;;
        "cursor:switch")
            # Complete with recent projects and common project directories
            local projects=""
            # Add recent projects from Cursor workspace storage
            if [ -d "$HOME/.cursor/User/workspaceStorage" ]; then
                projects=$(find "$HOME/.cursor/User/workspaceStorage" -name "*.json" -exec basename {} \; 2>/dev/null | sed 's/\.json$//')
            fi
            # Add common project directories
            if [ -d "$HOME/projects" ]; then
                projects="$projects $(ls "$HOME/projects" 2>/dev/null)"
            fi
            if [ -d "$HOME/work" ]; then
                projects="$projects $(ls "$HOME/work" 2>/dev/null)"
            fi
            mapfile -t COMPREPLY < <(compgen -W "${projects}" -- "${cur}")
            return 0
            ;;
        "cursor:ai:explain"|"cursor:ai:refactor"|"cursor:ai:test"|"cursor:ai:docs"|"cursor:ai:review")
            # Complete with file names
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
        "cursor:ext:install")
            # Complete with common extension IDs
            local common_extensions="ms-python.python ms-python.pylint ms-python.black-formatter rust-lang.rust-analyzer ms-vscode.vscode-typescript-next esbenp.prettier-vscode ms-vscode.vscode-eslint ms-vscode.vscode-json redhat.vscode-yaml ms-vscode.vscode-markdown"
            mapfile -t COMPREPLY < <(compgen -W "${common_extensions}" -- "${cur}")
            return 0
            ;;
        "cursor:ext:recommend")
            # Complete with project types
            local project_types="python rust javascript typescript web mobile data ml"
            mapfile -t COMPREPLY < <(compgen -W "${project_types}" -- "${cur}")
            return 0
            ;;
        "cursor:config:restore")
            # Complete with backup directories
            if [ -d "$HOME/.cursor-backups" ]; then
                local backups
                backups=$(ls "$HOME/.cursor-backups" 2>/dev/null)
                mapfile -t COMPREPLY < <(compgen -W "${backups}" -- "${cur}")
            fi
            return 0
            ;;
    esac
    
    # Handle multi-argument commands
    local first_arg=""
    if [ ${#COMP_WORDS[@]} -ge 2 ]; then
        first_arg="${COMP_WORDS[1]}"
    fi
    case "${first_arg}" in
        "cursor:new")
            # First argument is project type, second is project name
            if [ "${COMP_CWORD}" -eq 2 ]; then
                local project_types="web api mobile data ml cli lib"
                mapfile -t COMPREPLY < <(compgen -W "${project_types}" -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                # Complete with directory names for project location
                mapfile -t COMPREPLY < <(compgen -d -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:refactor")
            # First argument is file, second is refactor type
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local refactor_types="general performance readability security structure"
                mapfile -t COMPREPLY < <(compgen -W "${refactor_types}" -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:test")
            # First argument is file, second is test framework
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local test_frameworks="pytest unittest jest mocha rspec"
                mapfile -t COMPREPLY < <(compgen -W "${test_frameworks}" -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:docs")
            # First argument is file, second is doc format
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local doc_formats="markdown sphinx javadoc godoc rustdoc"
                mapfile -t COMPREPLY < <(compgen -W "${doc_formats}" -- "${cur}")
                return 0
            fi
            ;;
        "cursor:ai:review")
            # First argument is file, second is review focus
            if [ "${COMP_CWORD}" -eq 2 ]; then
                mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
                return 0
            elif [ "${COMP_CWORD}" -eq 3 ]; then
                local review_focus="general security performance style bugs best-practices"
                mapfile -t COMPREPLY < <(compgen -W "${review_focus}" -- "${cur}")
                return 0
            fi
            ;;
    esac
    
    return 0
}

# Export the caddie function and helper functions so they're available in subshells
export -f caddie
export -f caddie_help
export -f caddie_version
export -f caddie_extract_module_name

# Set up tab completion if available (bash 4.0+)
if command -v complete >/dev/null 2>&1; then
    # Clear any existing completion for caddie and register our completion function
    complete -r caddie 2>/dev/null || true
    complete -F _caddie_completion caddie
    export -f _caddie_completion
    echo "  ✓ Tab completion enabled"
else
    echo "  ⚠ Tab completion not available (bash 3.2 detected)"
fi

# Caddie is now ready to use!
echo "✓ Caddie.sh loaded successfully with all modules"
