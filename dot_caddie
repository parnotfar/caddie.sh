#!/bin/bash

# Function to display caddie help
function caddie_help() {
    caddie_debug "=== caddie_help function called ==="
    
    echo "Caddie.sh - Development Environment Manager"
    echo "=========================================="
    echo ""
    echo "Usage: caddie <command>"
    echo ""
    echo "Command Categories:"
    echo "  home                     Home directory management"
    
    echo "Available modules:"
    for m in $(caddie_modules_get); do
        description_function="caddie_${m}_description"
        printf "  %-10s %s\n" "$m" "$(eval "$description_function")"
    done
    
    echo
    echo "General Commands:"
    echo "  help                     Show this overview"
    echo "  version                  Show caddie version"
    echo
    echo "Detailed Help:"
    echo "  Use 'caddie <module>:help' for detailed information on any module"
    echo
}

# Function to show caddie version
function caddie_version() {
    if [ -f "$HOME/.caddie_version" ]; then
        source "$HOME/.caddie_version"
        echo "Caddie.sh version: $CADDIE_SH_VERSION"
    else
        echo "Caddie.sh version: unknown"
    fi
}

# Main caddie function - directly executes commands
function caddie() {
    local command="$1"

    shift  # Remove first argument (the command)

    caddie_debug "=== caddie function called ==="
    caddie_debug "command='$command'"
    caddie_debug "remaining args='$*'"
    
    # Handle built-in commands first
    case "$command" in
        "help"|"--help"|"-h")
            caddie_help
            return 0
            ;;
        "version"|"--version"|"-v")
            caddie_version
            return 0
            ;;
        "")
            caddie_help
            return 0
            ;;
    esac
    
    # Use naming convention: module:command -> caddie_module_command
    local function_name="caddie_${command//:/_}"
    
    if command -v "$function_name" >/dev/null 2>&1; then
        caddie_debug "Found function '$function_name', executing with args: $*"
        eval "$function_name \"\$@\""
    else
        echo "Error: Unknown command '$command'"
        caddie_help
        return 1
    fi
}

# --- completion setup ---
# 1) make ':' not break words (so ruby:add stays one token)
COMP_WORDBREAKS=${COMP_WORDBREAKS//:/}



_caddie_completion() {
  local cur prev words cword
  COMPREPLY=()

  # Prefer bash-completion helper if present; otherwise manual
  if declare -F _get_comp_words_by_ref >/dev/null 2>&1; then
    _get_comp_words_by_ref -n : cur prev words cword
  else
    words=("${COMP_WORDS[@]}")
    cword=${COMP_CWORD:-0}
    cur=${words[$cword]}
    prev=${words[$((cword-1))]}
  fi

  # First arg completion: commands & modules
  if (( cword == 1 )); then
    local base_opts="help version --help -h --version -v"
    # Collect modules (ensure one-per-line, no extra chatter)
    local modules=()
    if command -v caddie_modules_get >/dev/null 2>&1; then
      # read safely into array; suppress module function's stdout noise
      IFS=$'\n' read -r -d '' -a modules < <(caddie_modules_get 2>/dev/null; printf '\0')
    fi
    local all_opts="$base_opts ${modules[*]}"
    IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$all_opts" -- "$cur")
    return 0
  fi

  # Second+ arg completion: per-module subcommands
  case "${words[1]}" in
    python)
      local py_sub="init install update venv:activate venv:deactivate build test run lint format pip:freeze pip:audit"
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$py_sub" -- "$cur")
      return 0
      ;;
    ruby)
      local rb_sub="init bundle install update exec rake rspec rubocop"
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$rb_sub" -- "$cur")
      return 0
      ;;
    js|node|npm|pnpm|yarn)
      local js_sub="init install add update build dev start test lint format audit"
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$js_sub" -- "$cur")
      return 0
      ;;
    rust)
      local rs_sub="new build run test add remove fmt clippy check doc"
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$rs_sub" -- "$cur")
      return 0
      ;;
    ios)
      local ios_sub="build run test archive pods:install swift:version"
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$ios_sub" -- "$cur")
      return 0
      ;;
    core|cursor|cross)
      local core_sub="status set:home set:app get:app help"
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$core_sub" -- "$cur")
      return 0
      ;;
  esac

  return 0
}

# Helper function to extract module name from filename
function caddie_extract_module_name() {
    local filename="$1"
    basename "$filename" | sed 's/^\.caddie_//'
}

# Export the caddie function and helper functions so they're available in subshells
export -f caddie
export -f caddie_help
export -f caddie_version

# Source the dependent files
source "$HOME/.caddie_version"
source "$HOME/.caddie_prompt.sh"
source "$HOME/.caddie_git"
source "$HOME/.caddie_debug"

# Source data structure files
source "$HOME/.caddie_data/.caddie_modules"

# Auto-discover caddie modules from ~/.caddie_modules/ directory
# Each module file should have functions named <module>_caddie_description and <module>_caddie_help
CADDIE_MODULES_DIR="$HOME/.caddie_modules"

# Load all modules 
if [ -d "$CADDIE_MODULES_DIR" ]; then
    caddie_debug "=== Starting module loading process ==="
    caddie_debug "CADDIE_MODULES_DIR: $CADDIE_MODULES_DIR"

    # Reset modules array before loading
    caddie_modules_reset

    # Load all modules and populate modules array
    while IFS= read -r -d '' file; do
        source "$file"
        caddie_modules_append "$(caddie_extract_module_name "$file")"
    done < <(find "$CADDIE_MODULES_DIR" -name ".caddie_*" -type f -print0 2>/dev/null)
    
    caddie_debug "=== Module loading complete ==="
    caddie_debug "Final modules array contents: [$(caddie_modules_get)]"
else
    echo "Installation Error: The modules directory for caddie is not found.  Please reinstall caddie."
    return 1
fi

# Set up tab completion
if command -v complete >/dev/null 2>&1; then
    # Clear any existing completion for caddie and register our completion function
    complete -r caddie 2>/dev/null || true
    complete -o default -o nospace -F _caddie_completion caddie
    
    # Configure completion behavior
    bind 'set show-all-if-ambiguous off' 2>/dev/null || true
    bind 'set show-all-if-unmodified off' 2>/dev/null || true
    bind 'set completion-ignore-case off' 2>/dev/null || true
    
    echo "✓ Tab completion enabled"
else
    echo "⚠ Tab completion not available"
fi

# Caddie is now ready to use!
echo "✓ Caddie.sh loaded successfully"