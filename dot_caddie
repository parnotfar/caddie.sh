#!/bin/bash

source "$HOME/.caddie_modules/.caddie_core"

# Function to display caddie help
function caddie_help() {
    caddie cli:title "Caddie.sh - Development Environment Manager"
    caddie cli:blank
    
    caddie cli:usage "caddie <command>"
    caddie cli:blank
    
    caddie cli:title "Command Categories:"
    caddie cli:indent "home                     Home directory management"
    caddie cli:indent "aliases                  Alias search and management"
    
    caddie cli:title "Navigation:"
    caddie cli:indent "go:home                  Navigate to caddie home directory"
    
    caddie cli:title "Available modules:"

    local -a help_modules=()
    declare -A seen_help_modules=()

    if [ ${#CADDIE_MODULES[@]} -gt 0 ] 2>/dev/null; then
        for m in "${CADDIE_MODULES[@]}"; do
            if [ -n "$m" ] && [ -z "${seen_help_modules[$m]}" ]; then
                help_modules+=("$m")
                seen_help_modules[$m]=1
            fi
        done
    fi

    if [ ${#CADDIE_COMPLETION_ORDER[@]} -gt 0 ] 2>/dev/null; then
        for m in "${CADDIE_COMPLETION_ORDER[@]}"; do
            if [ -n "$m" ] && [ -z "${seen_help_modules[$m]}" ]; then
                help_modules+=("$m")
                seen_help_modules[$m]=1
            fi
        done
    fi

    if [ ${#help_modules[@]} -eq 0 ]; then
        caddie cli:indent "No modules registered"
    else
        local module description_function module_description
        for module in "${help_modules[@]}"; do
            description_function="caddie_${module}_description"
            module_description=""
            if declare -F "$description_function" >/dev/null 2>&1; then
                module_description="$($description_function)"
            fi
            if [ -z "$module_description" ]; then
                module_description="Registered module"
            fi
            printf "  %-10s %s\n" "$module" "$module_description"
        done
    fi
    
    caddie cli:blank
    caddie cli:title "General Commands:"
    caddie cli:indent "help                     Show this overview"
    caddie cli:indent "version                  Show caddie version"
    caddie cli:indent "reload                   Reload caddie"
    caddie cli:indent "(no args)                Launch interactive caddie prompt"
    caddie cli:blank
    caddie cli:title "Productivity:"
    caddie cli:indent "core:aliases             Show all available aliases"
    caddie cli:blank
    caddie cli:title "Detailed Help:"
    caddie cli:indent "Use 'caddie <module>:help' for detailed information on any module"
    caddie cli:blank
}

# Function to show caddie version
function caddie_version() {
    if [ -f "$HOME/.caddie_version" ]; then
        source "$HOME/.caddie_version"
        caddie cli:package "Caddie.sh version: $CADDIE_SH_VERSION"
    else
        caddie cli:warning "Caddie.sh version: unknown"
    fi
}

function _caddie_module_exists() {
    local needle="$1"
    local module

    if [ -z "$needle" ]; then
        return 1
    fi

    if [ "$needle" = "shell" ]; then
        return 0
    fi

    if [ ${#CADDIE_MODULES[@]} -gt 0 ] 2>/dev/null; then
        for module in "${CADDIE_MODULES[@]}"; do
            if [ "$module" = "$needle" ]; then
                return 0
            fi
        done
    fi

    if [ ${#CADDIE_COMPLETION_ORDER[@]} -gt 0 ] 2>/dev/null; then
        for module in "${CADDIE_COMPLETION_ORDER[@]}"; do
            if [ "$module" = "$needle" ]; then
                return 0
            fi
        done
    fi

    return 1
}

function _caddie_repl_normalize() {
    local line="$1"
    local active_module="${2:-}"
    local allow_scopes="${3:-1}"

    line="${line#${line%%[![:space:]]*}}"
    line="${line%${line##*[![:space:]]}}"

    if [ -z "$line" ]; then
        printf '%s\n' ""
        return 0
    fi

    if [[ "$line" == \`* ]] && [[ "$line" == *\` ]] && [ "${#line}" -ge 2 ]; then
        local shell_inline
        shell_inline="${line#\`}"  # trim leading backtick
        shell_inline="${shell_inline%\`}"  # trim trailing backtick
        printf '__SHELL_EVAL__%s\n' "$shell_inline"
        return 0
    fi

    case "$line" in
        exit|quit|q)
            printf '%s\n' "__EXIT__"
            return 0
            ;;
        back|up|..)
            if [ -n "$active_module" ] && [ "$allow_scopes" = "1" ]; then
                printf '%s\n' "__MODULE_EXIT__"
                return 0
            fi
            ;;
        help|--help|-h)
            if [ -n "$active_module" ]; then
                if [ "$active_module" = "shell" ]; then
                    printf '%s\n' "__SHELL_HELP__"
                else
                    printf '%s\n' "${active_module}:help"
                fi
            else
                printf '%s\n' "$line"
            fi
            return 0
            ;;
        version|--version|-v|reload|--reload|-r|go:home)
            printf '%s\n' "$line"
            return 0
            ;;
    esac

    if [[ "$line" == :* ]]; then
        printf '%s\n' "${line#:}"
        return 0
    fi

    local first_token
    first_token="${line%%[[:space:]]*}"

    if [ "$active_module" = "shell" ]; then
        printf '__SHELL_EVAL__%s\n' "$line"
        return 0
    fi

    if [ -n "$active_module" ]; then
        if [[ "$first_token" == *:* ]]; then
            printf '%s\n' "$line"
            return 0
        fi

        if [ "$line" = "$first_token" ] && _caddie_module_exists "$first_token" && [ "$allow_scopes" = "1" ]; then
            printf '%s\n' "__SET_MODULE__:${first_token}"
            return 0
        fi

        line="${active_module} ${line}"
        line="${line#${line%%[![:space:]]*}}"
        line="${line%${line##*[![:space:]]}}"
        first_token="${line%%[[:space:]]*}"
    fi

    if [[ "$first_token" == *:* ]]; then
        printf '%s\n' "$line"
        return 0
    fi

    local module rest
    module="${line%%[[:space:]]*}"
    rest="${line#${module}}"
    rest="${rest#${rest%%[![:space:]]*}}"

    if [ "$module" = "shell" ]; then
        if [ -z "$rest" ]; then
            if [ "$allow_scopes" = "1" ]; then
                printf '%s\n' "__SET_MODULE__:shell"
                return 0
            fi
            printf '%s\n' "shell:help"
            return 0
        fi
        case "$rest" in
            help|--help|-h)
                printf '%s\n' "__SHELL_HELP__"
                return 0
                ;;
        esac
        printf '__SHELL_EVAL__%s\n' "$rest"
        return 0
    fi

    if [ "$module" = "$line" ]; then
        if _caddie_module_exists "$module"; then
            if [ "$allow_scopes" = "1" ]; then
                printf '%s\n' "__SET_MODULE__:${module}"
                return 0
            fi
        fi
        printf '%s\n' "${module}:help"
        return 0
    fi

    local command command_tail
    command="${rest%%[[:space:]]*}"
    if [ "$command" = "$rest" ]; then
        printf '%s\n' "${module}:${command}"
        return 0
    fi

    command_tail="${rest#${command}}"
    command_tail="${command_tail#${command_tail%%[![:space:]]*}}"

    if [ -n "$command_tail" ]; then
        local next_token remaining
        next_token="${command_tail%%[[:space:]]*}"
        remaining="${command_tail#${next_token}}"
        remaining="${remaining#${remaining%%[![:space:]]*}}"

        if [ -n "$next_token" ] \
            && [[ "$command" != *:* ]] \
            && [[ "$next_token" != -* ]] \
            && [[ "$next_token" =~ ^[[:alnum:]_-]+$ ]]; then
            command="${command}:${next_token}"
            command_tail="$remaining"
        fi
    fi

    if [ -n "$command_tail" ]; then
        printf '%s\n' "${module}:${command} ${command_tail}"
    else
        printf '%s\n' "${module}:${command}"
    fi
    return 0
}

function _caddie_repl() {
    local line normalized status=0
    local prompt_name="caddie"
    local prompt_version=""
    local prompt_label="caddie"
    local active_module=""
    local history_file="${CADDIE_HISTORY_FILE:-$HOME/.caddie_history}"
    local history_initial_size
    local history_entries_added=0
    local -a repl_new_entries=()

    local previous_int_trap
    previous_int_trap="$(trap -p INT)"
    local interrupted=0
    trap 'interrupted=1' INT

    if [ -f "$HOME/.caddie_version" ]; then
        # shellcheck disable=SC1090
        source "$HOME/.caddie_version"
        if [ -n "${CADDIE_SH_VERSION:-}" ]; then
            prompt_version="-${CADDIE_SH_VERSION}"
            prompt_label="${prompt_name}${prompt_version}"
        fi
    fi

    history_initial_size=$(builtin history 2>/dev/null | wc -l | tr -d '[:space:]')
    if ! [[ "$history_initial_size" =~ ^[0-9]+$ ]]; then
        history_initial_size=0
    fi

    if [ -f "$history_file" ]; then
        while IFS= read -r history_line; do
            if [ -n "$history_line" ]; then
                builtin history -s "$history_line" 2>/dev/null || true
                history_entries_added=$((history_entries_added + 1))
            fi
        done < "$history_file"
    fi

    while true; do
        if [ -n "$active_module" ]; then
            prompt_label="${prompt_name}[${active_module}]${prompt_version}"
        else
            prompt_label="${prompt_name}${prompt_version}"
        fi

        interrupted=0
        if ! builtin read -e -r -p "${prompt_label}> " line; then
            if [ "$interrupted" = "1" ]; then
                printf '\n'
                interrupted=0
                continue
            fi
            printf '\n'
            break
        fi

        local trimmed_line="$line"
        trimmed_line="${trimmed_line#${trimmed_line%%[![:space:]]*}}"
        trimmed_line="${trimmed_line%${trimmed_line##*[![:space:]]}}"

        if [ -n "$trimmed_line" ]; then
            builtin history -s "$trimmed_line" 2>/dev/null || true
            history_entries_added=$((history_entries_added + 1))
            repl_new_entries+=("$trimmed_line")
        fi

        line="$trimmed_line"

        local normalized
        local normalized_set=0

        if [[ "$line" == \`* ]] && [[ "$line" == *\` ]] && [ "${#line}" -ge 2 ]; then
            local shell_inline
            shell_inline="${line#\`}"
            shell_inline="${shell_inline%\`}"
            normalized="__SHELL_EVAL__${shell_inline}"
            normalized_set=1
        elif [ "$active_module" = "shell" ]; then
            case "$line" in
                back|up|..)
                    normalized="__MODULE_EXIT__"
                    normalized_set=1
                    ;;
                help|--help|-h)
                    normalized="__SHELL_HELP__"
                    normalized_set=1
                    ;;
                "")
                    normalized=""
                    normalized_set=1
                    ;;
                *)
                    normalized="__SHELL_EVAL__${line}"
                    normalized_set=1
                    ;;
            esac
        fi

        if [ "$normalized_set" -eq 0 ]; then
            normalized="$(_caddie_repl_normalize "$line" "$active_module")"
        fi

        case "$normalized" in
            "")
                continue
                ;;
            "__EXIT__")
                break
                ;;
            "__MODULE_EXIT__")
                if [ -n "$active_module" ]; then
                    caddie cli:indent "Leaving module '${active_module}'"
                    active_module=""
                fi
                continue
                ;;
            "__SHELL_HELP__")
                caddie cli:title "Shell Scope"
                caddie cli:indent "Run shell commands directly from the REPL without leaving context."
                caddie cli:indent "Use backticks or 'shell <cmd>' for one-offs, or enter the scope with 'shell'."
                caddie cli:indent "Leave the shell scope with 'back', 'up', or '..'."
                continue
                ;;
            __SET_MODULE__*)
                active_module="${normalized#__SET_MODULE__:}"
                caddie cli:title "Module scope: ${active_module}"
                continue
                ;;
            __SHELL_EVAL__*)
                local shell_command
                shell_command="${normalized#__SHELL_EVAL__}"
                if [ -n "$shell_command" ]; then
                    interrupted=0
                    builtin eval "$shell_command"
                    status=$?
                else
                    status=0
                fi
                continue
                ;;
        esac

        if ! eval "set -- $normalized" 2>/dev/null; then
            caddie cli:red "Error: Unable to parse input"
            continue
        fi

        if [ $# -eq 0 ]; then
            continue
        fi

        interrupted=0
        caddie "$@"
        status=$?
    done

    if [ -n "$previous_int_trap" ]; then
        eval "$previous_int_trap"
    else
        trap - INT
    fi

    if [ ${#repl_new_entries[@]} -gt 0 ]; then
        if [ -z "$history_file" ]; then
            history_file="$HOME/.caddie_history"
        fi
        # Ensure directory exists when using nested path
        local history_dir
        history_dir="${history_file%/*}"
        if [ -n "$history_dir" ] && [ "$history_dir" != "$history_file" ]; then
            mkdir -p "$history_dir" 2>/dev/null || true
        fi
        printf '%s\n' "${repl_new_entries[@]}" >> "$history_file"
    fi

    if [ "$history_entries_added" -gt 0 ]; then
        local delete_index=$((history_initial_size + 1))
        local i
        for ((i = 0; i < history_entries_added; i++)); do
            builtin history -d "$delete_index" 2>/dev/null || true
        done
    fi

    return $status
}

# Main caddie function - directly executes commands and exposes REPL when no args
function caddie() {
    if [ $# -eq 0 ]; then
        _caddie_repl
        return $?
    fi

    if [[ "$1" != *:* ]]; then
        local normalized
        normalized="$(_caddie_repl_normalize "$*" "" "0")"

        if [ "$normalized" = "__EXIT__" ]; then
            return 0
        fi

        if [ "$normalized" = "__SHELL_HELP__" ]; then
            caddie cli:title "Shell Integration"
            caddie cli:indent "Use backticks (\`command\`) to run ad-hoc shell commands inside the REPL."
            caddie cli:indent "Type 'shell <command>' for one-off commands or 'shell' to enter shell scope."
            caddie cli:indent "Exit shell scope with 'back', 'up', or '..'."
            return 0
        fi

        if [[ "$normalized" == __SHELL_EVAL__* ]]; then
            local shell_cmd
            shell_cmd="${normalized#__SHELL_EVAL__}"
            if [ -n "$shell_cmd" ]; then
                builtin eval "$shell_cmd"
                return $?
            fi
            return 0
        fi

        if [ -n "$normalized" ]; then
            if ! eval "set -- $normalized" 2>/dev/null; then
                caddie cli:red "Unable to parse command"
                return 1
            fi
        else
            return 0
        fi
    fi

    local command="$1"
    shift || true

    case "$command" in
        help|--help|-h)
            caddie_help
            return 0
            ;;
        version|--version|-v)
            caddie_version
            return 0
            ;;
        reload|--reload|-r)
            source "$HOME/.bash_profile"
            return 0
            ;;
        go:home)
            caddie_core_go_home "$@"
            return 0
            ;;
        shell:help)
            caddie cli:title "Shell Integration"
            caddie cli:indent "Use backticks (\`command\`) to run ad-hoc shell commands inside the REPL."
            caddie cli:indent "Type 'shell <command>' for one-off commands or 'shell' to enter shell scope."
            caddie cli:indent "Exit shell scope with 'back', 'up', or '..'."
            return 0
            ;;
    esac

    local function_name="caddie_${command//:/_}"

    if command -v "$function_name" >/dev/null 2>&1; then
        eval "$function_name \"\$@\""
    else
        caddie cli:red "Error: Unknown command '$command'"
        caddie_help
        return 1
    fi
}

# --- completion setup ---
# 1) make ':' not break words (so ruby:add stays one token)
COMP_WORDBREAKS=${COMP_WORDBREAKS//:/}

declare -Ag CADDIE_COMPLETION_MAP=()
CADDIE_COMPLETION_ORDER=()

function caddie_completion_clear() {
  CADDIE_COMPLETION_MAP=()
  CADDIE_COMPLETION_ORDER=()
  return 0
}

function caddie_completion_register() {
  local module="$1"
  local commands="$2"

  if [ -z "$module" ] || [ -z "$commands" ]; then
    return 1
  fi

  CADDIE_COMPLETION_MAP["$module"]="$commands"

  local existing_module
  for existing_module in "${CADDIE_COMPLETION_ORDER[@]}"; do
    if [ "$existing_module" = "$module" ]; then
      return 0
    fi
  done

  CADDIE_COMPLETION_ORDER+=("$module")
  return 0
}

export -f caddie_completion_clear
export -f caddie_completion_register

function _caddie_completion() {
  local cur prev words cword
  COMPREPLY=()

  # Prefer bash-completion helper if present; otherwise manual
  if declare -F _get_comp_words_by_ref >/dev/null 2>&1; then
    _get_comp_words_by_ref -n : cur prev words cword
  else
    words=("${COMP_WORDS[@]}")
    cword=${COMP_CWORD:-0}
    cur=${words[$cword]}
    prev=${words[$((cword-1))]}
  fi

  if [[ "$prev" == git:pr:approve ]]; then
    local pr_candidates=""

    if declare -F caddie_git_pr_completion_candidates >/dev/null 2>&1; then
      pr_candidates=$(caddie_git_pr_completion_candidates 2>/dev/null || true)
    fi

    if [ -n "$pr_candidates" ]; then
      IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$pr_candidates" -- "$cur")
    else
      COMPREPLY=()
    fi

    return 0
  fi

  # Build a flat list of all accepted commands
  local base_opts="help version go:home shell --help -h --version -v reload --reload -r"
  local all_opts="$base_opts"

  if [ ${#CADDIE_COMPLETION_ORDER[@]} -gt 0 ] 2>/dev/null; then
    local completion_module
    for completion_module in "${CADDIE_COMPLETION_ORDER[@]}"; do
      local completion_cmds="${CADDIE_COMPLETION_MAP[$completion_module]}"
      if [ -n "$completion_cmds" ]; then
        all_opts+=" $completion_cmds"
      fi
    done
  fi
  
  # Complete with all available commands
  IFS=$'\n' mapfile -t COMPREPLY < <(compgen -W "$all_opts" -- "$cur")
  
  # If we have multiple completions and the current word contains a colon,
  # try to provide more specific completions for subcommands
  if [[ ${#COMPREPLY[@]} -gt 1 && "$cur" == *:* ]]; then
    # Extract the prefix (everything before the last colon)
    local prefix="${cur%:*}"
    local subcommand_prefix="$prefix:"
    
    # Filter completions to only show those that start with the subcommand prefix
    local filtered_completions=()
    for completion in "${COMPREPLY[@]}"; do
      if [[ "$completion" == "$subcommand_prefix"* ]]; then
        filtered_completions+=("$completion")
      fi
    done
    
    # If we found filtered completions, use them
    if [[ ${#filtered_completions[@]} -gt 0 ]]; then
      COMPREPLY=("${filtered_completions[@]}")
    fi
  fi
  
  return 0
}

# Helper function to extract module name from filename
function caddie_extract_module_name() {
    local filename="$1"
    basename "$filename" | sed 's/^\.caddie_//'
}

# Export the caddie function and helper functions so they're available in subshells
export -f caddie
export -f caddie_help
export -f caddie_version

# Source the dependent files
source "$HOME/.caddie_version"
source "$HOME/.caddie_prompt.sh"

# Source data structure files
source "$HOME/.caddie_data/.caddie_modules"

# Auto-discover caddie modules from ~/.caddie_modules/ directory
# Each module file should have functions named <module>_caddie_description and <module>_caddie_help
CADDIE_MODULES_DIR="$HOME/.caddie_modules"

# Load all modules 
if [ -d "$CADDIE_MODULES_DIR" ]; then
    # Reset modules array before loading
    caddie_modules_reset
    caddie_prompt_clear_segments
    caddie_completion_clear

    # Load all modules and populate modules array
    while IFS= read -r -d '' file; do
        module_name=""
        prompt_fn=""
        completion_registered=0
        completion_fn=""
        completion_output=""
        source "$file"
        module_name="$(caddie_extract_module_name "$file")"
        caddie_modules_append "$module_name"
        prompt_fn="caddie_${module_name}_prompt_segment"
        if declare -F "$prompt_fn" >/dev/null 2>&1; then
            caddie_prompt_register_segment "$prompt_fn"
        fi

        completion_registered=0
        completion_fn="caddie_${module_name}_commands"
        if declare -F "$completion_fn" >/dev/null 2>&1; then
            completion_output="$($completion_fn)"
            if [ -n "$completion_output" ]; then
                caddie_completion_register "$module_name" "$completion_output"
                completion_registered=1
            fi
        fi

        if [ "$completion_registered" != "1" ]; then
            case "$module_name" in
              python)
                caddie_completion_register "$module_name" "python:init python:install python:update python:venv:activate python:venv:deactivate python:build python:test python:run python:lint python:format python:pip:freeze python:pip:audit"
                ;;
              ruby)
                caddie_completion_register "$module_name" "ruby:init ruby:bundle ruby:install ruby:update ruby:exec ruby:rake ruby:rspec ruby:rubocop"
                ;;
              js)
                caddie_completion_register "$module_name" "js:init js:install js:add js:update js:build js:dev js:start js:test js:lint js:format js:audit"
                ;;
              rust)
                caddie_completion_register "$module_name" "rust:init rust:new rust:build rust:run rust:run:example rust:example:run rust:test rust:test:unit rust:test:integration rust:test:all rust:test:property rust:test:bench rust:test:watch rust:test:coverage rust:add rust:remove rust:fmt rust:format rust:clippy rust:check rust:fix rust:fix:all rust:clean rust:update rust:search rust:outdated rust:audit rust:toolchain rust:target rust:component rust:git:status rust:gitignore rust:git:clean"
                ;;
              ios)
                caddie_completion_register "$module_name" "ios:build ios:run ios:test ios:archive ios:pods:install ios:swift:version ios:rust:setup"
                ;;
              core)
                caddie_completion_register "$module_name" "core:status core:set:home core:set:app core:get:app core:help core:aliases core:alias:grep core:alias:git core:alias:docker core:alias:npm core:alias:nav core:lint core:lint:limit"
                ;;
              cursor)
                caddie_completion_register "$module_name" "cursor:open cursor:new cursor:switch cursor:ai:explain cursor:ai:refactor cursor:ai:test cursor:ai:docs cursor:ai:review cursor:ext:install cursor:ext:recommend cursor:config:restore"
                ;;
              cross)
                caddie_completion_register "$module_name" "cross:template:create"
                ;;
              git)
                caddie_completion_register "$module_name" "git:status git:branch git:new:branch git:commit git:gacp git:auth:login git:pr:create git:pr:approve git:push git:push:set:upstream git:pull git:clone git:remote:add git:remote:set-url git:remote:list git:remote:remove"
                ;;
              github)
                caddie_completion_register "$module_name" "github:account:set github:account:get github:account:unset github:auth:check github:repo:create github:repo:url"
                ;;
              cli)
                caddie_completion_register "$module_name" "cli:red cli:green cli:yellow cli:blue cli:purple cli:cyan cli:grey cli:orange cli:white cli:red:bold cli:green:bold cli:yellow:bold cli:blue:bold cli:purple:bold cli:cyan:bold cli:grey:bold cli:orange:bold cli:white:bold cli:usage cli:installed cli:complete cli:title cli:colorlist cli:check cli:x cli:arrow cli:folder cli:beer cli:snake cli:crab cli:trash cli:rotate cli:chart cli:magnify cli:save cli:warning cli:debug cli:wrench cli:whale cli:package cli:git cli:rocket cli:thought cli:lightbulb cli:magnifying_glass cli:blank cli:indent cli:help"
                ;;
              debug)
                caddie_completion_register "$module_name" "debug:on debug:off debug:status debug:help"
                ;;
            esac
        fi
    done < <(find "$CADDIE_MODULES_DIR" -name ".caddie_*" -type f -print0 2>/dev/null)
else
    caddie cli:warning "Installation Error: The modules directory for caddie is not found.  Please reinstall caddie."
    return 1
fi

# Set up tab completion
if command -v complete >/dev/null 2>&1; then
    # Clear any existing completion for caddie and register our completion function
    complete -r caddie 2>/dev/null || true
    complete -o default -F _caddie_completion caddie
    
    # Configure completion behavior
    bind 'set show-all-if-ambiguous off' 2>/dev/null || true
    bind 'set show-all-if-unmodified off' 2>/dev/null || true
    bind 'set completion-ignore-case off' 2>/dev/null || true
    
    caddie cli:check "Tab completion enabled"
else
    caddie cli:warning "Tab completion not available"
fi

# Caddie is now ready to use!
caddie cli:check "Caddie.sh loaded successfully"
