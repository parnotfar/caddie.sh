#!/bin/bash

# Caddie.sh - Main Entry Point
# This file sources all the modular components and provides the main interface

# Source the module management system first
source "$HOME/.caddie_modules"

# Define caddie modules and their descriptions.
# Each entry should be in the format "key|Description", where:
#   - key:     The module name (used for sourcing ~/.caddie_<key>)
#   - Description: A human-readable description for help output.
# Example: "rust|Rust development tools" means the module "rust" will be loaded from ~/.caddie_rust,
#          and its description will be shown in help listings.
CADDIE_MODULES=(
    "core|Core caddie functions"
    "python|Python environment management"
    "rust|Rust development tools"
    "ios|iOS development tools"
    "cross|Cross-language features"
    "cursor|Cursor IDE integration"
)

# Load all modules and register them
for moddesc in "${CADDIE_MODULES[@]}"; do
    module="${moddesc%%|*}"
    desc="${moddesc#*|}"
    file="$HOME/.caddie_${module}"
    if [ -f "$file" ]; then
        source "$file"
        caddie_module_help_register "$module" "$desc"
    else
        echo "Warning: ${desc} module not found at $file"
    fi
done

# Discover all available commands from all modules
CADDIE_COMMANDS=()
for moddesc in "${CADDIE_MODULES[@]}"; do
    module="${moddesc%%|*}"
    if [ -n "$module" ]; then
        # Call module's registration function to get its commands
        if command -v "${module}_caddie_register" >/dev/null 2>&1; then
            while IFS= read -r cmd_info; do
                if [ -n "$cmd_info" ]; then
                    CADDIE_COMMANDS+=("$cmd_info")
                fi
            done < <("${module}_caddie_register")
        fi
    fi
done

# Main caddie function - dynamically routes commands to modules
caddie() {
    local command="$1"
    local args=("$@")
    
    # Try to route to a module using dynamic command discovery
    for cmd_info in "${CADDIE_COMMANDS[@]}"; do
        parse_cmd_registration "$cmd_info"
        
        if [ "$command" = "$PARSED_CMD_PATTERN" ]; then
            # Call the module's function with remaining arguments
            # Remove the first argument (the command) and pass the rest
            local remaining_args=("${args[@]:1}")
            eval "${PARSED_FUNC_NAME} \"\${remaining_args[@]}\""
            return 0
        fi
    done
    
    # Handle core commands and errors
    case "$command" in
        "help"|"--help"|"-h")
            caddie_help
            ;;
        "version"|"--version"|"-v")
            caddie_version
            ;;
        "")
            echo "Caddie.sh - Development Environment Manager"
            echo "Use 'caddie help' for available commands"
            ;;
        *)
            echo "Error: Unknown command '$command'"
            echo "Use 'caddie help' for available commands"
            return 1
            ;;
    esac
}

# Shared function to parse command registration format
# Input: "module:command|function|description" (pipe-separated for easy parsing)
# Output: module, cmd_part, func_name, description, cmd_pattern
parse_cmd_registration() {
    local cmd_info="$1"
    
    # Split on pipe character for clean parsing (bash 3.2 compatible)
    local module_cmd=$(echo "$cmd_info" | cut -d'|' -f1)
    local func_name=$(echo "$cmd_info" | cut -d'|' -f2)
    local description=$(echo "$cmd_info" | cut -d'|' -f3)
    
    # Split module:command to get module and command parts
    local module="${module_cmd%%:*}"
    local cmd_part="${module_cmd#*:}"
    
    # Build the command pattern for matching
    local cmd_pattern="${module}:${cmd_part}"
    
    # Return values via global variables (bash 3.2 compatible)
    PARSED_MODULE="$module"
    PARSED_CMD_PART="$cmd_part"
    PARSED_FUNC_NAME="$func_name"
    PARSED_DESCRIPTION="$description"
    PARSED_CMD_PATTERN="$cmd_pattern"
}

# Tab completion function for caddie command
_caddie_completion() {
    local cur prev opts
    COMPREPLY=()
    
    # Safely access COMP_WORDS array elements
    if [ -n "$COMP_CWORD" ] && [ ${COMP_CWORD} -ge 0 ] && [ ${COMP_CWORD} -lt ${#COMP_WORDS[@]} ]; then
        cur="${COMP_WORDS[COMP_CWORD]}"
    else
        cur=""
    fi
    
    if [ -n "$COMP_CWORD" ] && [ ${COMP_CWORD} -ge 1 ] && [ ${COMP_CWORD} -lt ${#COMP_WORDS[@]} ]; then
        prev="${COMP_WORDS[COMP_CWORD-1]}"
    else
        prev=""
    fi
    
    # Build available caddie commands dynamically from discovered commands
    local opts="help version --help -h --version -v"
    for cmd_info in "${CADDIE_COMMANDS[@]}"; do
        parse_cmd_registration "$cmd_info"
        if [ -n "$PARSED_CMD_PATTERN" ]; then
            opts="$opts $PARSED_CMD_PATTERN"
        fi
    done
    
    # If we're completing the first argument (command)
    if [ -n "$COMP_CWORD" ] && [ ${COMP_CWORD} -eq 1 ]; then
        # Use compgen to generate completions from our options
        local IFS=$'\n'
        COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
        return 0
    fi
    
    # Handle completion for specific commands that take arguments
    case "${prev}" in
        "core:set:home")
            # Complete with directory names
            COMPREPLY=( $(compgen -d -- "${cur}") )
            return 0
            ;;
        "python:create"|"python:activate"|"python:remove")
            # Complete with existing virtual environment names
            if [ -d "$HOME/.virtualenvs" ]; then
                local venvs=$(ls "$HOME/.virtualenvs" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${venvs}" -- "${cur}") )
            fi
            return 0
            ;;
        "python:install"|"python:uninstall"|"python:upgrade")
            # Complete with installed packages (if pip is available)
            if command -v pip >/dev/null 2>&1; then
                local packages=$(pip list --format=freeze 2>/dev/null | cut -d'=' -f1)
                COMPREPLY=( $(compgen -W "${packages}" -- "${cur}") )
            fi
            return 0
            ;;
        "rust:new")
            # Complete with directory names for project location
            COMPREPLY=( $(compgen -d -- "${cur}") )
            return 0
            ;;
        "rust:add"|"rust:remove")
            # Complete with installed crates (if cargo is available)
            if [ -f "Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
                local crates=$(grep -E '^[[:space:]]*[a-zA-Z0-9_-]+[[:space:]]*=' Cargo.toml 2>/dev/null | sed 's/[[:space:]]*\([a-zA-Z0-9_-]*\)[[:space:]]*=.*/\1/')
                COMPREPLY=( $(compgen -W "${crates}" -- "${cur}") )
            fi
            return 0
            ;;
        "rust:toolchain")
            # Complete with common Rust toolchain versions
            local toolchains="stable beta nightly"
            COMPREPLY=( $(compgen -W "${toolchains}" -- "${cur}") )
            return 0
            ;;
        "rust:target")
            # Complete with common Rust targets
            local targets="x86_64-unknown-linux-gnu aarch64-apple-darwin x86_64-apple-darwin x86_64-pc-windows-msvc"
            COMPREPLY=( $(compgen -W "${targets}" -- "${cur}") )
            return 0
            ;;
        "rust:component")
            # Complete with common Rust components
            local components="clippy rustfmt rust-src rust-analysis"
            COMPREPLY=( $(compgen -W "${components}" -- "${cur}") )
            return 0
            ;;
        "cross:template:create")
            # Complete with available template types
            local templates="web cli api data ml lib wasm app framework extension mobile"
            COMPREPLY=( $(compgen -W "${templates}" -- "${cur}") )
            return 0
            ;;
        # Cursor integration completions
        "cursor:open")
            # Complete with directory names
            COMPREPLY=( $(compgen -d -- "${cur}") )
            return 0
            ;;
        "cursor:new")
            # Complete with project types
            local project_types="web api mobile data ml cli lib"
            COMPREPLY=( $(compgen -W "${project_types}" -- "${cur}") )
            return 0
            ;;
        "cursor:switch")
            # Complete with recent projects and common project directories
            local projects=""
            # Add recent projects from Cursor workspace storage
            if [ -d "$HOME/.cursor/User/workspaceStorage" ]; then
                projects=$(find "$HOME/.cursor/User/workspaceStorage" -name "*.json" -exec basename {} \; 2>/dev/null | sed 's/\.json$//')
            fi
            # Add common project directories
            if [ -d "$HOME/projects" ]; then
                projects="$projects $(ls "$HOME/projects" 2>/dev/null)"
            fi
            if [ -d "$HOME/work" ]; then
                projects="$projects $(ls "$HOME/work" 2>/dev/null)"
            fi
            COMPREPLY=( $(compgen -W "${projects}" -- "${cur}") )
            return 0
            ;;
        "cursor:ai:explain"|"cursor:ai:refactor"|"cursor:ai:test"|"cursor:ai:docs"|"cursor:ai:review")
            # Complete with file names
            COMPREPLY=( $(compgen -f -- "${cur}") )
            return 0
            ;;
        "cursor:ext:install")
            # Complete with common extension IDs
            local common_extensions="ms-python.python ms-python.pylint ms-python.black-formatter rust-lang.rust-analyzer ms-vscode.vscode-typescript-next esbenp.prettier-vscode ms-vscode.vscode-eslint ms-vscode.vscode-json redhat.vscode-yaml ms-vscode.vscode-markdown"
            COMPREPLY=( $(compgen -W "${common_extensions}" -- "${cur}") )
            return 0
            ;;
        "cursor:ext:recommend")
            # Complete with project types
            local project_types="python rust javascript typescript web mobile data ml"
            COMPREPLY=( $(compgen -W "${project_types}" -- "${cur}") )
            return 0
            ;;
        "cursor:config:restore")
            # Complete with backup directories
            if [ -d "$HOME/.cursor-backups" ]; then
                local backups=$(ls "$HOME/.cursor-backups" 2>/dev/null)
                COMPREPLY=( $(compgen -W "${backups}" -- "${cur}") )
            fi
            return 0
            ;;
    esac
    
    # Handle multi-argument commands
    local first_arg=""
    if [ ${#COMP_WORDS[@]} -ge 2 ]; then
        first_arg="${COMP_WORDS[1]}"
    fi
    case "${first_arg}" in
        "cursor:new")
            # First argument is project type, second is project name
            if [ ${COMP_CWORD} -eq 2 ]; then
                local project_types="web api mobile data ml cli lib"
                COMPREPLY=( $(compgen -W "${project_types}" -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                # Complete with directory names for project location
                COMPREPLY=( $(compgen -d -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:refactor")
            # First argument is file, second is refactor type
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local refactor_types="general performance readability security structure"
                COMPREPLY=( $(compgen -W "${refactor_types}" -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:test")
            # First argument is file, second is test framework
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local test_frameworks="pytest unittest jest mocha rspec"
                COMPREPLY=( $(compgen -W "${test_frameworks}" -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:docs")
            # First argument is file, second is doc format
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local doc_formats="markdown sphinx javadoc godoc rustdoc"
                COMPREPLY=( $(compgen -W "${doc_formats}" -- "${cur}") )
                return 0
            fi
            ;;
        "cursor:ai:review")
            # First argument is file, second is review focus
            if [ ${COMP_CWORD} -eq 2 ]; then
                COMPREPLY=( $(compgen -f -- "${cur}") )
                return 0
            elif [ ${COMP_CWORD} -eq 3 ]; then
                local review_focus="general security performance style bugs best-practices"
                COMPREPLY=( $(compgen -W "${review_focus}" -- "${cur}") )
                return 0
            fi
            ;;
    esac
    
    return 0
}

# Clear any existing completion for caddie and register our completion function
complete -r caddie 2>/dev/null || true
complete -F _caddie_completion caddie

# Export the caddie function so it's available in subshells
export -f caddie
export -f _caddie_completion

# Caddie is now ready to use!
echo "âœ“ Caddie.sh loaded successfully with all modules"
