#!/usr/bin/env bash

# Caddie.sh - Core Environment Management
# This file contains all core functions and the debug system

# Source CLI module for formatting
source "$HOME/.caddie_modules/.caddie_cli"

# Global variables
CADDIE_HOME_FILE="$HOME/.caddie_home"

# Function to provide module description
function caddie_core_description() {
    echo 'Core system functions and debugging utilities'
    return 0
}

function caddie_core_help() {
    echo 'core:debug <on|off> - Enable or disable debug logging'
    echo 'core:version - Show caddie version information'
    echo 'core:reload - Reload caddie environment'
    echo 'core:home - Set or show caddie home directory'
    echo 'core:lint [target] - Lint shell scripts with ShellCheck + custom rules'
    echo 'core:lint:limit <n> <target> - Lint with limited output per check'
    return 0
}

# Function to enable/disable debug logging
function caddie_core_debug() {
    local action="$1"
    
    if [ -z "$action" ]; then
        caddie cli:red "Error: Action required"
        caddie cli:usage "caddie core:debug <on|off>"
        return 1
    fi
    
    case "$action" in
        on)
            export CADDIE_DEBUG=1
            caddie cli:check "Debug logging enabled"
            ;;
        off)
            export CADDIE_DEBUG=0
            caddie cli:check "Debug logging disabled"
            ;;
        *)
            caddie cli:red "Error: Invalid action '$action'"
            caddie cli:usage "caddie core:debug <on|off>"
            return 1
            ;;
    esac
    return 0
}

# Function to show version information
function caddie_core_version() {
    caddie cli:title "Caddie.sh Version Information"
    caddie cli:blank
    
    if [ -f "$HOME/.caddie_version" ]; then
        source "$HOME/.caddie_version"
        caddie_version_show
    else
        caddie cli:red "Version file not found"
        return 1
    fi
    
    caddie cli:blank
    caddie cli:indent "Shell: $SHELL"
    caddie cli:indent "Bash version: $BASH_VERSION"
    caddie cli:indent "Home directory: $HOME"
    caddie cli:indent "Caddie modules: $HOME/.caddie_modules"
    
    return 0
}

# Function to reload caddie environment
function caddie_core_reload() {
    caddie cli:title "Reloading Caddie Environment"
    
    # Source the main caddie file
    if [ -f "$HOME/.caddie.sh" ]; then
        source "$HOME/.caddie.sh"
        caddie cli:check "Caddie environment reloaded"
    else
        caddie cli:red "Error: Main caddie file not found at $HOME/.caddie.sh"
        return 1
    fi
    
    return 0
}

# Function to set or show caddie home directory
function caddie_core_home() {
    local new_home="$1"
    
    if [ -n "$new_home" ]; then
        # Set new home directory
        if [ -d "$new_home" ]; then
            echo "$new_home" > "$CADDIE_HOME_FILE"
            caddie cli:check "Caddie home set to: $new_home"
        else
            caddie cli:red "Error: Directory '$new_home' does not exist"
            return 1
        fi
    else
        # Show current home directory
        if [ -f "$CADDIE_HOME_FILE" ]; then
            local current_home=$(cat "$CADDIE_HOME_FILE")
            caddie cli:blue "Current caddie home: $current_home"
        else
            caddie cli:blue "Current caddie home: $HOME"
        fi
    fi
    
    return 0
}

# caddie:lint:disable
function caddie_core_lint() {
    local target="${1:-modules/}"
    local limit_per_check="${2:-0}"  # 0 means no limit (show all)
    local total_issues=0

    caddie cli:title "Caddie Lint - ShellCheck + Custom Rules"
    caddie cli:blank

    if [ ! -e "$target" ]; then
        caddie cli:red "Error: Target '$target' does not exist"
        return 1
    fi

    # Build an array of files safely (handles spaces/newlines)
    local -a files=()
    if [ -d "$target" ]; then
        while IFS= read -r -d '' f; do
            files+=("$f")
        done < <(find "$target" -type f \( -name "*.sh" -o -name "dot_caddie*" \) -print0 | sort -z)
    else
        files+=("$target")
    fi

    if [ "${#files[@]}" -eq 0 ]; then
        caddie cli:warning "No shell files found in '$target'"
        return 0
    fi

    caddie cli:folder "Checking ${#files[@]} file(s)..."
    caddie cli:blank

    if ! command -v shellcheck >/dev/null 2>&1; then
        caddie cli:red "ShellCheck not found. Please run: make install"
        caddie cli:indent "This will install ShellCheck via Homebrew as part of the development setup"
        return 1
    fi

    for file in "${files[@]}"; do
        # skip nonexistent (just in case)
        [ -f "$file" ] || continue

        # skip if linter self-check marker exists
        if [[ "$file" == *"dot_caddie_core"* ]] && grep -q "caddie:lint:disable" "$file"; then
            caddie cli:indent "Checking: $file"
            caddie cli:yellow "  ⚠ Skipping linter self-check (has ignore blocks)"
            continue
        fi

        caddie cli:indent "Checking: $file"
        local file_issues=0

        # Run ShellCheck and process its output without subshell counters
        local shellcheck_output
        shellcheck_output=$(shellcheck -f gcc "$file" 2>&1 || true)
        if [ -n "$shellcheck_output" ]; then
            local sc_count=0
            while IFS= read -r line; do
                [ -n "$line" ] || continue
                if [ "$limit_per_check" -eq 0 ] || [ "$sc_count" -lt "$limit_per_check" ]; then
                    caddie cli:yellow "  ⚠ $line"
                fi
                sc_count=$((sc_count + 1))
            done <<<"$shellcheck_output"

            # count total lines reported by shellcheck
            local total_shellcheck
            total_shellcheck=$(printf '%s\n' "$shellcheck_output" | wc -l | tr -d ' ')
            file_issues=$((file_issues + total_shellcheck))
        fi

        # Run custom checks and add the returned number
        local custom_issues
        custom_issues=$(caddie_core_lint_custom "$file" "$limit_per_check")
        file_issues=$((file_issues + custom_issues))

        if [ "$file_issues" -eq 0 ]; then
            caddie cli:check "  ✓ All checks passed"
        else
            caddie cli:yellow "  ⚠ $file_issues issue(s)"
        fi

        total_issues=$((total_issues + file_issues))
    done

    caddie cli:blank
    if [ "$total_issues" -eq 0 ]; then
        caddie cli:check "✓ All files passed caddie standards!"
        return 0
    else
        caddie cli:yellow "Completed with $total_issues issue(s)"
        caddie cli:blank
        return 1
    fi
}

# Custom caddie-specific linting checks
function caddie_core_lint_custom() {
    local file="$1"
    local limit="$2"
    local issues=0

    limit="${limit:-3}"

    # helper to apply limit on grep output
    apply_limit() {
        local input="$1"

        if [ "${limit}" -eq 0 ]; then
            printf '%s\n' "${input}"
        else
            printf '%s\n' "${input}" | head -n "${limit}"
        fi
    }

    # 1) CLI module sourcing for dot_caddie_* files (except dot_caddie_cli)
    if [[ "$file" == *"dot_caddie_"* ]] && [[ "$file" != *"dot_caddie_cli"* ]]; then
        if ! grep -q 'source.*\.caddie_cli' "$file"; then
            caddie cli:red "  ✗ Missing CLI module sourcing (should source ~/.caddie_modules/.caddie_cli)"
            issues=$((issues + 1))
        fi
    fi
 
    # 2) Function naming convention: find declared caddie_ functions
    # We require explicit "function" keyword: "function name() {"

    local func_lines
    func_lines=$(
        awk '/^[[:space:]]*function[[:space:]]+caddie_[a-zA-Z0-9_]+\s*\(\)\s*\{/{print FNR ":" $0}' "${file}"
    ) || true

    if [ -n "${func_lines}" ]; then
        # Validate each function name: must be caddie_<module>_<command> (two underscores min)
        while IFS= read -r fl; do
            [ -n "${fl}" ] || continue
            # extract name
            local lineno=${fl%%:*}
            local line=${fl#*:}
            # extract the function name token
            # remove leading spaces and 'function' keyword
            local name
            name=$(printf '%s\n' "$line" | sed -E 's/^[[:space:]]*function[[:space:]]+//; s/\s*\(\).*//; s/[[:space:]]*$//')

            # check the name has exactly two underscore groups at minimum
            if ! printf '%s' "$name" | grep -qE '^caddie_[a-z0-9]+_[a-z0-9]+'; then
                caddie cli:red "  ✗ Invalid function naming (should be caddie_<module>_<command>):"
                caddie cli:red "    Line ${lineno}: ${name}"
                issues=$((issues + 1))
            fi
        done <<<"$func_lines"
    fi

    # 3) Function exports: ensure functions are exported if they follow naming convention
    # collect function names using compatible approach
    local functions_output
    functions_output=$(
        awk '
            # Match either "function name() {" or "name() {", where name starts with caddie_
            /^[[:space:]]*(function[[:space:]]+)?caddie_[a-zA-Z0-9_]+\s*\(\)\s*\{/ {
                # Remove optional leading "function " and any leading whitespace
                $0 = gensub(/^[[:space:]]*(function[[:space:]]+)?/, "", "g", $0)

                # Remove everything from the "(" onward, leaving just the identifier
                sub(/\s*\(\).*$/, "", $0)

                # Trim leading and trailing whitespace
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)

                # Print the cleaned function name
                print $0
            }
        ' "${file}"
    ) || true

    # collect exports using compatible approach
    local exports_output
    exports_output=$(
        grep -Eo 'export[[:space:]]+-f[[:space:]]+caddie_[a-zA-Z0-9_]+' "${file}"
    ) || true
    
    # normalize exports to names only
    local normalized_exports=""
    if [ -n "${exports_output}" ]; then
        normalized_exports=$(printf '%s\n' "$exports_output" | awk '{print $NF}')
    fi

    # check each function against exports
    if [ -n "${functions_output}" ]; then
        while IFS= read -r func; do
            [ -n "${func}" ] || continue
            if ! printf '%s\n' "${normalized_exports}" | grep -q "^${func}$"; then
                caddie cli:red "  ✗ Function '$func' is not exported"
                issues=$((issues + 1))
            fi
        done <<<"${functions_output}"
    fi

    # 4) Help/description functions: require caddie_<module>_help / _description for dot_caddie_*
    if [[ "${file}" == *"dot_caddie_"* ]] && [[ "${file}" != *"dot_caddie_core"* ]]; then
        local module_name
        module_name=$(basename "${file}" | sed 's/^dot_caddie_//; s/\.sh$//')

        if ! grep -q "function caddie_${module_name}_help" "$file"; then
            caddie cli:red "  ✗ Missing help function (caddie_${module_name}_help)"
            issues=$((issues + 1))
        fi

        if ! grep -q "function caddie_${module_name}_description" "$file"; then
            caddie cli:red "  ✗ Missing description function (caddie_${module_name}_description)"
            issues=$((issues + 1))
        fi
    fi

    # 5) Echo message standards - advise use of caddie cli:* helpers
    local usage_echoes
    usage_echoes=$(
        apply_limit "$(
            grep -n 'echo "Usage' "${file}"
        )" || true
    ) || true

    if [ -n "${usage_echoes}" ]; then
        caddie cli:yellow "  ⚠ Use 'caddie cli:usage' instead of 'echo \"Usage...\"':"

        while IFS= read -r line; do
            caddie cli:yellow "    Line $line"
        done <<<"${usage_echoes}"

        issues=$((issues + 1))
    fi

    local check_echoes
    check_echoes=$(
        apply_limit "$(
            grep -n 'echo "✓' "${file}"
        )" || true
    ) || true

    if [ -n "${check_echoes}" ]; then
        caddie cli:yellow "  ⚠ Use 'caddie cli:check' instead of 'echo \"✓...\"':"

        while IFS= read -r line; do
            caddie cli:yellow "    Line $line"
        done <<<"${check_echoes}"

        issues=$((issues + 1))
    fi

    local fail_echoes
    fail_echoes=$(
        apply_limit "$(
            grep -n 'echo "✗' "${file}"
        )" || true
    ) || true

    if [ -n "${fail_echoes}" ]; then
        caddie cli:yellow "  ⚠ Use 'caddie cli:red' instead of 'echo \"✗...\"':"

        while IFS= read -r line; do
            caddie cli:yellow "    Line $line"
        done <<<"${fail_echoes}"

        issues=$((issues + 1))
    fi

    # 6) Printf vs Echo - recommend printf for better portability
    local echo_usage
    echo_usage=$(
        apply_limit "$(
            grep -n '^[[:space:]]*echo [^"]' "${file}" | grep -v 'echo "Usage' | grep -v 'echo "✓' | grep -v 'echo "✗' | grep -v 'echo "Error' | grep -v '| while' | grep -v '| head' | grep -v '| wc'
        )" || true
    ) || true

    if [ -n "${echo_usage}" ]; then
        caddie cli:yellow "  ⚠ Consider using 'printf' instead of 'echo' for better portability:"

        while IFS= read -r line; do
            caddie cli:yellow "    Line ${line}"
        done <<<"${echo_usage}"

        issues=$((issues + 1))
    fi

    # 7) False positive return 0 - detect return 0 after output commands
    local false_returns

    false_returns=$(
        apply_limit "$(
            awk '/^[[:space:]]*(echo|printf)[[:space:]]/ { 
                getline next_line; 
                if (next_line ~ /^[[:space:]]*return[[:space:]]+0[[:space:]]*$/) { 
                    print (NR-1) ":" $0; 
                    print NR ":" next_line 
                } 
            }' "${file}"
        )"
    )

    false_returns=${false_returns:-""}

    #while IFS= read -r curline; do
    #    #caddie cli:yellow "    Line ${curline}"
    #done <<<"${false_returns}"

    #    caddie cli:yellow "  Avoid using 'return 0' after output commands (can mask failures):"
    #    issues=$((issues + 1))
    #fi

    printf '%d\n' "${issues}"
}
# caddie:lint:enable

# Function to run caddie-specific linting with limit
function caddie_core_lint_limit() {
    local limit="$1"
    local target="$2"
    if [ -z "$limit" ] || [ -z "$target" ]; then
        caddie cli:red "Error: Both limit and target are required"
        caddie cli:usage "caddie core:lint:limit <limit> <target>"
        return 1
    fi
    caddie_core_lint "$target" "$limit"
    return $?
}

# Export functions
export -f caddie_core_description
export -f caddie_core_help
export -f caddie_core_debug
export -f caddie_core_version
export -f caddie_core_reload
export -f caddie_core_home
export -f caddie_core_lint
export -f caddie_core_lint_custom
export -f caddie_core_lint_limit
